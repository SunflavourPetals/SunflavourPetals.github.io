<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++20 比宏更好用的source_location</title>
      <link href="/2024/02/09/%E6%AF%94%E5%AE%8F%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84source-location/"/>
      <url>/2024/02/09/%E6%AF%94%E5%AE%8F%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84source-location/</url>
      
        <content type="html"><![CDATA[<h3 id="引"><a href="#引" class="headerlink" title="引"></a>引</h3><pre><code class="C++">// 你不会喜欢这个#if defined(_UNICODE) || defined(UNICODE)#define MY_FILET __FILEW__#else#define MY_FILET __FILE__#endif#define MY_THROW_IF_FAILED(code) \    ::my::ThrowIfFailed(code, TEXT(#code), MY_FILET, __LINE__);</code></pre><a href="#注"><div><i>在过去的日子里，邪恶当道！</i><br /><p align="right"><i>——Kristen Nygaard</i></p></div><div><i>而且，我还持有这样的观点：Cpp必须被摧毁。</i><br />  <p align="right"><i>——老加图（Marcus Porcius Cato）</i></p><br />  </div>  </a><h3 id="曾经当下可用的C"><a href="#曾经当下可用的C" class="headerlink" title="曾经当下可用的C++"></a>曾经当下可用的C++</h3><p>在<text id="dragon">《DX12 3D 游戏开发实战》</text>出版之际(指英文原版，出版日期2016&#x2F;03&#x2F;24，引用自<a href="https://www.amazon.com/Introduction-3D-Game-Programming-DirectX/dp/1942270062">亚马逊</a>)，C++还处于准备迈入C++17的时代。“<a href="#%E5%BC%95">引</a>”中的代码是其中示例的一个变形：API往往返回一个<code>HRESULT</code>类型的值(可以看作是一种错误码)，然后我们可通过<code>FAILED</code>宏来检测返回值是否代表失败。如果失败，还要调用<code>_com_error::ErrorMessgae</code>来获取失败信息，并将文件名、行号、代码和错误信息一并塞到一个自定义异常类的对象里，并抛出它。在程序出错时，这些信息对正在学习D3D的人将很有帮助。  </p><p>“引”中的代码是我根据记忆改写的，可以发现，如果我们无Cpp(C语言预处理器)可用，那么我们将不得不在每次调用<code>my::ThrowIfFailed</code>这个函数时手动填写<code>__FILE__</code>&#x2F;<code>__FILEW__</code>和<code>__LINE__</code>，作为第三和第四个参数，对于大量的检测需求，手工代码代价高昂，耗尽了我们的精力……</p><h4 id="为什么是宏"><a href="#为什么是宏" class="headerlink" title="为什么是宏"></a>为什么是宏</h4><p>宏或者不是一个宏，这是个问题。有什么诡计能让我们同时避免宏和手动填写参数吗？有人可能会想到给函数填写默认参数，但是很遗憾，函数默认参数是行不通的，这种方法不能得到我们想要的效果。最后我们妥协了，选择了宏——如果有其他更好的办法，弗兰克叔叔为什么不告诉我们呢？我记得<a href="https://www.amazon.com/Introduction-3D-Game-Programming-DirectX/dp/1942270062">龙书</a>作者曾在书里阐述过原因，如果你了解宏只是简单的文本替换，你也能马上明白原因所在。预处理能让宏 <code>__FILE__</code>、<code>__LINE__</code> 出现在源文件中正确的位置，此处就不赘述了。  </p><p>此外，<code>TEXT(#code)</code> 这样的东西只适用于MSVC，在 gcc 等平台无法通过编译(如有兴趣可以详细查看预处理器的那些规则)，其中<code>TEXT</code>是宏，可能的实现：  </p><pre><code class="C++">#if defined(_UNICODE) || defined(UNICODE)#define TEXT(quote) L##quote#else#define TEXT(quote) quote#endif</code></pre><p>测试以默认参数的形式实现与ThrowIfFailed相似的代码：  </p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;string&gt;void bad_log(std::string_view msg, const char* caller, const char* file = __FILE__, int line = __LINE__)&#123;    std::cout        &lt;&lt; &quot;FILE: &quot; &lt;&lt; file &lt;&lt; &quot; LINE: &quot; &lt;&lt; line &lt;&lt; &quot; CALLER: &quot; &lt;&lt; caller        &lt;&lt; &quot; MSG: &quot; &lt;&lt; msg &lt;&lt; &quot;\n&quot;;&#125;int main()&#123;    bad_log(&quot;Hell&quot;, __FUNCTION__);    bad_log(&quot;Hell&quot;, __func__);&#125;</code></pre><p>可能的输出：</p><pre><code>FILE: xxx/main.cpp LINE: 5 CALLER: main MSG: HellFILE: xxx/main.cpp LINE: 5 CALLER: main MSG: Hell</code></pre><p>很明显不是我们要的效果，在这个程序中，不管在哪里使用默认参数调用<code>bad_log</code>，它的实参<code>line</code>总是<code>5</code>，由于<code>bad_log</code>调用和<code>bad_log</code>的声明同处一个源文件，它能以我们期望的方式工作，但这不够，如果我们在头文件里对<code>bad_log</code>进行声明(包括默认参数的定义)，它将不能按我们的意愿工作(值总是代表声明它的头文件的名称，使用MSVC测试)。<br>简而言之：Only MACRO can do.  </p><h3 id="当下可用的C"><a href="#当下可用的C" class="headerlink" title="当下可用的C++"></a>当下可用的C++</h3><p>我在写这篇文章的时候，正值除夕(实际写到这里时已经到正月初一了)，可以说各种意义上都进入2024年了。C++23尚且不能被支持完善，但是C++20可用。然而就在C++20中，标准库中增加了<code>std::source_location</code>，以解决我们的燃眉之急：  </p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;source_location&gt;void log(std::string_view msg = &quot;&quot;, const std::source_location&amp; location = std::source_location::current())&#123;    std::cout        &lt;&lt; &quot;FILE: &quot;    &lt;&lt; location.file_name()        &lt;&lt; &quot;(&quot;         &lt;&lt; location.line() &lt;&lt; &quot;,&quot; &lt;&lt; location.column() &lt;&lt; &quot;)&quot;        &lt;&lt; &quot; CALLER: &quot; &lt;&lt; location.function_name()        &lt;&lt; &quot; MSG: &quot;    &lt;&lt; msg &lt;&lt; &quot;\n&quot;;&#125;int main()&#123;    log(&quot;Hello&quot;);&#125;</code></pre><p>可能的输出(MSVC)：</p><pre><code>FILE: xxx/main.cpp(16,2) CALLER: int __cdecl main(void) MSG: Hello</code></pre><p>注：全部使用<code>TAB</code>表示缩进而非空格（这会影响<code>column</code>的返回值，如果使用四个空格表示缩进，我想<code>column</code>的返回值会是<code>5</code>）。  </p><p>这正是我们想要的。</p><h4 id="std-source-location-current"><a href="#std-source-location-current" class="headerlink" title="std::source_location::current"></a>std::source_location::current</h4><p><code>std::source_location::current</code>函数将构造一个表示调用位置的 source_location 对象。  </p><p>若直接调用 <code>current()</code> （通过指名 <code>current()</code> 的函数调用），则它返回对应调用位置的拥有实现定义值的 <code>source_location</code> 对象。该值应当以同预定义宏 <code>__LINE__</code> 与 <code>__FILE__</code> 的方式受 <code>#line</code> 预处理指令影响。<br>若在默认成员初始化器中使用 <code>current()</code>，则返回值对应初始化该数据成员的构造函数定义或聚合初始化的位置。<br>若 <code>current()</code> 用于默认参数，则返回值对应对 <code>current()</code> 的调用的调用点位置。<br>若以任何其他方式调用 <code>current()</code> ，则返回值未指定。  </p><p>注：<code>std::source_location::current</code> 通常要求编译器的内建实现。  </p><p>以上是 <a href="https://zh.cppreference.com/w/cpp/utility/source_location">c++ reference</a> 中的描述(稍有改动)。<br>以下是我写的示例：  </p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;source_location&gt;// curr line: 4void log(std::string_view msg = &quot;&quot;, const std::source_location&amp; location = std::source_location::current())&#123;    std::cout        &lt;&lt; &quot;FILE: &quot; &lt;&lt; location.file_name()        &lt;&lt; &quot;(&quot; &lt;&lt; location.line() &lt;&lt; &quot;,&quot; &lt;&lt; location.column() &lt;&lt; &quot;)&quot;        &lt;&lt; &quot; CALLER: &quot; &lt;&lt; location.function_name()        &lt;&lt; &quot; MSG: &quot; &lt;&lt; msg &lt;&lt; &quot;\n&quot;;&#125;// curr line: 13struct T1 // 使用默认成员初始化器&#123;    std::source_location loc = std::source_location::current();&#125;;// curr line: 18struct T2 // 使用构造函数的成员初始化器列表&#123;    T2() : loc&#123; std::source_location::current() &#125; &#123;&#125;    std::source_location loc;&#125;;// curr line: 24struct T3 // 将在main函数中使用聚合初始化&#123;    std::source_location loc;&#125;;// curr line: 29int main()&#123;    T1 t1&#123;&#125;; // curr line: 32    log(&quot;T1&quot;, t1.loc);    T2 t2&#123;&#125;; // curr line: 34    log(&quot;T2&quot;, t2.loc);    T3 t3&#123; std::source_location::current() &#125;; // curr line: 36    log(&quot;T3&quot;, t3.loc);    return 0;&#125;</code></pre><p>可能的输出(MSVC)：  </p><pre><code>FILE: xxx\main.cpp(32,8) CALLER: int __cdecl main(void) MSG: T1FILE: xxx\main.cpp(21,36) CALLER: __cdecl T2::T2(void) MSG: T2FILE: xxx\main.cpp(36,31) CALLER: int __cdecl main(void) MSG: T3</code></pre><p>预处理指令 <code>#line</code> 影响 <code>std::source_location::current</code> 的例子：  </p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;source_location&gt;void log(std::string_view msg = &quot;&quot;, const std::source_location&amp; location = std::source_location::current())&#123;    std::cout        &lt;&lt; &quot;FILE: &quot; &lt;&lt; location.file_name()        &lt;&lt; &quot;(&quot; &lt;&lt; location.line() &lt;&lt; &quot;,&quot; &lt;&lt; location.column() &lt;&lt; &quot;)&quot;        &lt;&lt; &quot; CALLER: &quot; &lt;&lt; location.function_name()        &lt;&lt; &quot; MSG: &quot; &lt;&lt; msg &lt;&lt; &quot;\n&quot;;&#125;int main()&#123;#line 123456 &quot;foo.cpp&quot;    u8&quot;😁&quot;; // __LINE__: 123456    log(&quot;after #line&quot;, std::source_location::current());  // __LINE__: 123457    return 0;&#125;</code></pre><p>可能的输出(MSVC)：  </p><pre><code>FILE: xxx\foo.cpp(123457,43) CALLER: int __cdecl main(void) MSG: after #line</code></pre><p>预处理指令 <code>#line</code> 的 <a href="https://zh.cppreference.com/w/cpp/preprocessor/line" title="预处理指令 #line">c++ reference</a>。  </p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>在使用C++时，总会听到别人建议“尽量避免使用宏”等。正如题注所隐含的信息，本贾尼就不喜欢C语言预处理器，C++也在竭力提供不依靠预处理器的选择，比如模板使得程序员不必再使用宏来泛型编程、模块使得程序员摆脱<code>#include</code>指令是唯一选择的境地、包括本文所提到的<code>std::source_location</code>也淡化了使用<code>__FILE__</code>和<code>__LINE__</code>的必要性，毕竟，我们现在有新的、更优的方式达到我们的目的。  </p><p>在没有模板的时期编写一个支持泛型的工具 be like：  </p><pre><code class="CC">// stack.hclass ELEM_stack&#123;    ELEM *min, *top, *max;    ...&#125;</code></pre><pre><code class="CC">// main.cpp#define ELEM int#define ELEM_stack int_stack#include &quot;stack.h&quot;#undef ELEM#undef ELEM_stack#define ELEM float#define ELEM_stack float_stack#include &quot;stack.h&quot;#undef ELEM#undef ELEM_stackint_stack is;float_stack fs;</code></pre><blockquote><p>源自《C++语言的设计和演化》(2.9.2 没有模板时的容器类)。</p></blockquote><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><h4 id="引-1"><a href="#引-1" class="headerlink" title="_引"></a>_引</h4><p><em>这<a href="#%E5%BC%95">两句话</a>分别为《C++语言设计与演化》的第一章《C++的史前时代》与最后一章《C语言预处理器》的题记（引用的是中文译本，裘宗燕译。题记中的“Cpp”指“C语言预处理器——C Preprocessor”）。老加图是古罗马政治家，老加图自然不可能对C语言预处理器有什么意见，这句话是模仿的老加图的名言：迦太基必须被摧毁。</em>  </p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
          <category> CPP20 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> CPP20 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享VS2022Preview新UI</title>
      <link href="/2024/02/03/%E5%88%86%E4%BA%ABVS2022Preview%E6%96%B0UI/"/>
      <url>/2024/02/03/%E5%88%86%E4%BA%ABVS2022Preview%E6%96%B0UI/</url>
      
        <content type="html"><![CDATA[<h3 id="标题五个字"><a href="#标题五个字" class="headerlink" title="标题五个字"></a>标题五个字</h3><img src="img_01.png" alt="效果图1" data-align="center"><img src="img_02.png" alt="效果图2" data-align="center"><img src="img_03.png" alt="效果图3" data-align="center"><ul><li>Microsoft Visual Studio Community 2022 (64 位) - Preview</li><li>版本 17.9.0 Preview 5.0</li></ul><p>漂亮得很呐，<del>用上新 ui 立马就觉得老 ui 丑到看不下去了</del>。</p><img src="meme_alice_kawaii.jpg" alt="meme_alice_可爱！" width="330" height="261" data-align="center">]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C风格字符串与CPP的矛盾</title>
      <link href="/2024/01/16/C%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8ECPP%E7%9A%84%E7%9F%9B%E7%9B%BE/"/>
      <url>/2024/01/16/C%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8ECPP%E7%9A%84%E7%9F%9B%E7%9B%BE/</url>
      
        <content type="html"><![CDATA[<style>.rev {    color: #101595;}</style><h3 id="引"><a href="#引" class="headerlink" title="引"></a>引</h3><img src="blue_pen.jpg" alt="蓝的盆" width="353" height="264" data-align="center"><p>声明：乱写的。  </p><h3 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h3><ol><li>字符串字面量持有类型 <code>const char_t[N]</code>，字符串长度等于 <code>N-1</code>；  </li><li>字符串字面量保证 <code>&quot;...&quot;[N-1]</code> 为 NUL，其中N是(1)中的N；  </li><li>C风格字符串以NUL字符表示字符串结束；  </li><li>字符串字面量通常被用以表示C风格字符串；  </li><li>字符数组对象退化为指针，丢失数组大小信息，容易产生越界访问甚至引起错误；  </li><li>字符串字面量所表示的C风格字符串通常以 <code>const char*</code> 的形式被引用；  </li><li>从类型上无法区分字符串字面量和字符数组(<code>const char[N]</code>)；  </li><li>函数无法区分实参是字符串字面量还是字符数组；  </li><li>C风格API的参数列表 <code>(const char* str, size_t len)</code> 对安全的保证无济于事；  </li><li><code>std::string</code> 不同于C风格字符串，它允许字符串内存在NUL字符；  </li><li><code>std::string</code> 保证 <code>str[str.length()]</code> 为 NUL，保证被当作C风格字符串时符合“以NUL结尾”的规则；  </li><li><code>std::string</code> 提供了 <code>c_str</code> 成员函数；  </li><li>当 <code>std::string</code> 字符串内存在NUL字符时，按C风格字符串的规则，<code>c_str</code> 表示的C风格字符串被字符串内第一个NUL字符“截断”；  </li><li>若 <code>std::string</code> 字符串内存在NUL字符，作为C风格字符串(<code>c_str</code>)时的行为和其本身<a href="#14">不一致</a>； </li><li><code>std::string_view</code> 是字符串视图；  </li><li><code>std::string_view</code> 不同于C风格字符串，它允许字符串内存在NUL字符；  </li><li><code>std::string_view</code> 不保证 <code>str[str.length()]</code> 为 NUL；  </li><li><code>std::string_view</code> 不提供 <code>c_str</code> 成员函数；  </li><li><code>std::string_view</code> 可能是某个字符串的子串；  </li><li><code>std::string_view</code> 不持有所表示的字符串的所有权，而像是一种引用；  </li><li>仅将字符串字面量作为实参用于构造 <code>std::string</code> 和&#x2F;或 <code>std::string_view</code>，将匹配到接受C风格字符串的构造函数；  </li><li>字符串字面量中可以出现值为 NUL 的元素；  </li><li>通过用户自定义字面量的方式使用标准库中的 <code>operator&quot;&quot;s</code> 从字符串字面量构造 <code>std::string</code> 对象；  </li><li>通过用户自定义字面量的方式使用标准库中的 <code>operator&quot;&quot;sv</code> 从字符串字面量构造 <code>std::string_view</code> 对象；  </li><li>通过用户自定义字面量获得的 <code>std::string</code>、<code>std::string_view</code> 对象，字符串长度总是 <code>N-1</code>，不管字符串字面量中是否有 NUL，而(20)中的构造方法则会受 NUL 元素的影响，<a href="#25">示例</a>。</li></ol><h3 id="事项和建议"><a href="#事项和建议" class="headerlink" title="事项和建议"></a>事项和建议</h3><ul><li><div class="rev">使用现代C++，</div>  </li><li><div class="rev">尽量使用 string 和 string_view，</div>  </li><li><div class="rev">尽量避免使用字符数组表示字符串，</div>  </li><li><div class="rev">尽量使用用户自定义字面量通过字符串字面量获得string或string_view对象，</div>  </li><li><div class="rev">当函数接收字符串作为输入参数(不修改)时，考虑使用 string_view 做形参的类型：T foo(string_view in);，</div>  </li><li><div class="rev">当函数接收字符串作为输入输出参数且需要修改它的元素时，考虑使用 span&lt;char_t> 做形参的类型(C++20)，</div>  </li><li><div class="rev">当函数接收字符串作为输入输出参数且需要修改它时(可能增长或缩短)，考虑使用 string& 做形参的类型，</div>  </li><li><div class="rev">函数向调用方输出字符串应当优先采用返回值的方式返回 string 类型字符串，</div>  </li><li><div class="rev">不要让 string_view 的生命周期长于它引用的字符串的生命周期，如不要返回从局部(自动存储期) string 对象得来的 string_view，对于 span 同理，它们都不拥有资源的所有权，而像是一种“引用”，</div>  </li><li><div class="rev">字符串字面量具有静态存储期。</div></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="14"><a href="#14" class="headerlink" title="14"></a>14</h4><pre><code class="C++">cout &lt;&lt; string&#123; &quot;str\0ing&quot;, 7 &#125; &lt;&lt; &quot;\n&quot;;cout &lt;&lt; string&#123; &quot;str\0ing&quot;, 7 &#125;.c_str() &lt;&lt; &quot;\n&quot;;</code></pre><p>结果：</p><pre><code>stringstr</code></pre><h4 id="25"><a href="#25" class="headerlink" title="25"></a>25</h4><pre><code class="C++">using namespace std::string_literals;using namespace std::string_view_literals;cout &lt;&lt; string&#123; &quot;str\0ing&quot; &#125; &lt;&lt; &quot;\n&quot;;cout &lt;&lt; string_view&#123; &quot;str\0ing&quot; &#125; &lt;&lt; &quot;\n&quot;;cout &lt;&lt; &quot;str\0ing&quot;s &lt;&lt; &quot;\n&quot;;cout &lt;&lt; &quot;str\0ing&quot;sv &lt;&lt; &quot;\n&quot;;</code></pre><p>结果：</p><pre><code>strstrstringstring</code></pre>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++20 三路比较运算符的使用</title>
      <link href="/2023/09/22/CPP20%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/09/22/CPP20%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<style>    .other_topic {        color: #528252;    }</style><h1 id="C-20三路比较运算符-“”"><a href="#C-20三路比较运算符-“”" class="headerlink" title="C++20三路比较运算符 “&lt;&#x3D;&gt;”"></a>C++20三路比较运算符 “&lt;&#x3D;&gt;”</h1><p>三路比较运算符是 C++20 标准新加入的运算符，本文将介绍三路比较运算符的基本使用和为用户自定义类型提供它的方法。<br>与三路比较运算符相关内容在标头 <code>&lt;compare&gt;</code> 中。</p><h2 id="三路比较运算符的使用"><a href="#三路比较运算符的使用" class="headerlink" title="三路比较运算符的使用"></a>三路比较运算符的使用</h2><h3 id="三路比较运算符的返回值类型"><a href="#三路比较运算符的返回值类型" class="headerlink" title="三路比较运算符的返回值类型"></a>三路比较运算符的返回值类型</h3><p>C++20新增三路比较运算符，用于确定两个值的大小顺序。内置类型的三路比较运算符返回值不为bool类型的纯右值，而是如下类类型之一的一个纯右值。  </p><div id="ordering_types">C++为我们提供的三种相应的类型：</div>  <ul><li><code>std::strong_ordering</code>  </li><li><code>std::partial_ordering</code>  </li><li><code>std::weak_ordering</code></li></ul><p>它们可以被称为“类枚举类型”(使用方法和”C++枚举类-<a href="https://zh.cppreference.com/w/cpp/language/enum" title="cppref">有作用域枚举</a>“有相似之处，但为类类型，故两者是完全不同的东西)。  </p><h3 id="三种ordering的隐式转换"><a href="#三种ordering的隐式转换" class="headerlink" title="三种ordering的隐式转换"></a>三种ordering的隐式转换</h3><p><span id="ordering_cast"> 三种ordering的隐式转换 </span></p><p>其中<code>std::strong_ordering</code>可以隐式转换为<code>std::weak_ordering</code>；<br><code>std::weak_ordering</code>可以隐式转换为<code>std::partial_ordering</code>。</p><h3 id="strong-ordering-强序"><a href="#strong-ordering-强序" class="headerlink" title="strong_ordering 强序"></a>strong_ordering 强序</h3><p>对于整数类型(包括指针类型)和bool类型，三路比较运算的结果是<code>std::strong_ordering</code>类型的，<br>其值为下列值之一：  </p><ul><li><code>std::strong_ordering::less</code> ：指示先序关系，即左操作数小于右操作数  </li><li><code>std::strong_ordering::greater</code> ：指示后序关系，即左操作数大于右操作数  </li><li><code>std::strong_ordering::equivalent</code> ：<text id="intr_equivalent">指示等价关系，即左操作数等于右操作数</text>  </li><li><code>std::strong_ordering::equal</code> (与<a href="#intr_equivalent">equivalent</a>相同)</li></ul><p>注：如果三路比较运算的两操作数一方为bool类型而另一方不是，那么程序非良构。</p><h3 id="partial-ordering-偏序"><a href="#partial-ordering-偏序" class="headerlink" title="partial_ordering 偏序"></a>partial_ordering 偏序</h3><p>对于浮点类型，结果则是<code>std::partial_ordering</code>类型的，<br>其值为下列值之一：  </p><ul><li><code>std::partial_ordering::less</code> ：指示先序关系，即左操作数小于右操作数  </li><li><code>std::partial_ordering::greater</code> ：指示后序关系，即左操作数大于右操作数  </li><li><code>std::partial_ordering::equivalent</code> ：指示等价关系，即左操作数等于右操作数  </li><li><code>std::partial_ordering::unordered</code> ：指示不可比较值的关系，当操作数中存在<code>NaN</code>时结果为<code>unordered</code></li></ul><p>注：正负零的三路比较运算结果为<code>equivalent</code>  </p><h3 id="weak-ordering-弱序"><a href="#weak-ordering-弱序" class="headerlink" title="weak_ordering 弱序"></a>weak_ordering 弱序</h3><p>对于为用户自定义类型提供的三路比较运算符，如果不考虑使用上述两种类型作为返回值类型，则可以考虑<code>std::weak_ordering</code>，<br>其值为下列值之一：  </p><ul><li><code>std::weak_ordering::less</code> ：指示先序关系，即左操作数小于右操作数  </li><li><code>std::weak_ordering::greater</code> ：指示后序关系，即左操作数大于右操作数  </li><li><code>std::weak_ordering::equivalent</code> ：指示等价关系，即左操作数等于右操作数</li></ul><h3 id="更方便地使用ordering"><a href="#更方便地使用ordering" class="headerlink" title="更方便地使用ordering"></a>更方便地使用ordering</h3><p>对于上述提到的类型，C++标准提供了六种和字面量<code>0</code>进行比较的运算符重载，用以确定两个值的大小顺序。设<code>ordering_v</code>为上述三种ordering类型中任意类型的值，则：</p><ol><li><code>ordering_v &gt; 0</code> or <code>0 &lt; ordering_v</code>时 ：对应<code>less</code>  </li><li><code>ordering_v &gt;= 0</code> or <code>0 &lt;= ordering_v</code>时 ：对应<code>less</code>∨<code>equivalent</code>  </li><li><code>ordering_v &lt; 0</code>or<code>0 &gt; ordering_v</code>时 ：对应<code>greater</code>  </li><li><code>ordering_v &lt;= 0</code>or<code>0 &gt;= ordering_v</code>时 ：对应<code>greater</code>∨<code>equivalent</code>  </li><li><code>ordering_v == 0</code> or <code>0 == ordering_v</code>时 ：对应<code>equivalent</code>  </li><li><code>ordering_v != 0</code> or <code>0 != ordering_v</code>时 ：对应┐<code>equivalent</code>(非<code>equivalent</code>)</li></ol><h4 id="具名比较函数"><a href="#具名比较函数" class="headerlink" title="具名比较函数"></a>具名比较函数</h4><p>这些函数取三路比较的结果，并转换为六个关系运算符的结果之一。</p><ol><li><code>std::is_eq</code>  </li><li><code>std::is_neq</code>  </li><li><code>std::is_lt</code>  </li><li><code>std::is_lteq</code>  </li><li><code>std::is_gt</code>  </li><li><code>std::is_gteq</code></li></ol><p>设形参名为<code>ordering_v</code>，这些函数将分别返回：</p><ol><li><code>ordering_v == 0</code>  </li><li><code>ordering_v != 0</code>  </li><li><code>ordering_v &lt; 0</code>  </li><li><code>ordering_v &lt;= 0</code>  </li><li><code>ordering_v &gt; 0</code>  </li><li><code>ordering_v &gt;= 0</code></li></ol><h3 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h3><pre><code class="C++">#include &lt;iostream&gt;// #include &lt;compare&gt; // 相关内容在标头compare中int main()&#123;    using namespace std;    cout &lt;&lt; boolalpha;    auto case_generator = [](auto foo, auto bar)    &#123;        auto print = [](const auto&amp; result)        &#123;            cout                &lt;&lt; &quot; == &quot; &lt;&lt; (result == 0) &lt;&lt; &#39;\n&#39;                &lt;&lt; &quot; != &quot; &lt;&lt; (result != 0) &lt;&lt; &#39;\n&#39;                &lt;&lt; &quot; &lt;  &quot; &lt;&lt; (result &lt;  0) &lt;&lt; &#39;\n&#39;                &lt;&lt; &quot; &lt;= &quot; &lt;&lt; (result &lt;= 0) &lt;&lt; &#39;\n&#39;                &lt;&lt; &quot; &gt;  &quot; &lt;&lt; (result &gt;  0) &lt;&lt; &#39;\n&#39;                &lt;&lt; &quot; &gt;= &quot; &lt;&lt; (result &gt;= 0) &lt;&lt; &#39;\n&#39;;        &#125;;        cout &lt;&lt; &quot;case equivalent\n&quot;;        foo = 100;        bar = 100;        print(foo &lt;=&gt; bar);        cout &lt;&lt; &quot;case less\n&quot;;        foo = 100;        bar = 999;        print(foo &lt;=&gt; bar);        cout &lt;&lt; &quot;case greater\n&quot;;        foo = 999;        bar = 100;        print(foo &lt;=&gt; bar);    &#125;;    cout &lt;&lt; &quot;Integer: \n&quot;;    case_generator(0, 0);    cout &lt;&lt; &quot;Floating point: \n&quot;;    case_generator(0.0, 0.0);    return 0;&#125;</code></pre><p>结果为</p><pre><code>Integer:case equivalent == true != false &lt;  false &lt;= true &gt;  false &gt;= truecase less == false != true &lt;  true &lt;= true &gt;  false &gt;= falsecase greater == false != true &lt;  false &lt;= false &gt;  true &gt;= trueFloating point:case equivalent == true != false &lt;  false &lt;= true &gt;  false &gt;= truecase less == false != true &lt;  true &lt;= true &gt;  false &gt;= falsecase greater == false != true &lt;  false &lt;= false &gt;  true &gt;= true</code></pre><p>对于不同类型间使用三路比较运算符的详细规则，请参阅<a href="https://zh.cppreference.com/w/cpp/language/operator_comparison">cpp-reference</a></p><hr><h2 id="为用户自定义类型提供三路比较运算符"><a href="#为用户自定义类型提供三路比较运算符" class="headerlink" title="为用户自定义类型提供三路比较运算符"></a>为用户自定义类型提供三路比较运算符</h2><p>为用户自定义类型提供三路比较运算符可以将其定义为成员函数和非成员函数(友元)两种方式。</p><p>三路比较运算符返回值类型应当为<a href="#ordering_types">三种ordering</a>中任意一个，但是如果要改变为其他类型比如<code>int</code>也是可以的，程序员在编写代码的时候应该清楚自己在做什么。</p><pre><code class="C++">// 重载三路比较运算符示例// 成员函数形式：class CX1&#123;    int val&#123;&#125;;    int insignificant_things&#123;&#125;;public:    auto operator &lt;=&gt; (const CX1&amp; o) const    &#123;        return this-&gt;val &lt;=&gt; o.val;    &#125;&#125;;// 友元函数形式(推荐)：class CX2&#123;    int val&#123;&#125;;    int insignificant_things&#123;&#125;;public:    friend auto operator &lt;=&gt; (const CX2&amp; ol, const CX2&amp; or)    &#123;        return ol.val &lt;=&gt; or.val;    &#125;&#125;;</code></pre><div class="other_topic">题外话：  <p>我更推荐将某一类型的 <code>+</code>, <code>-</code>, <code>&gt;</code>, <code>==</code>, <code>&lt;=&gt;</code> 等 rhs 与 lhs 地位平等的运算符以非成员函数的形式在与目标类型<code>T</code>所处的命名空间中(无需担心名称查找的问题)提供。  </p><pre><code class="C++">namespace mytest&#123;    struct my_t    &#123;        int data&#123;&#125;;                // 形式一        [[nodiscard]] friend constexpr auto operator== (const my_t&amp; lhs, const my_t&amp; rhs) noexcept        &#123;            return lhs.data == rhs.data;        &#125;    &#125;;    // 形式二(是否需要设置为友元函数请根据情况判断)    [[nodiscard]] constexpr auto operator&lt;=&gt; (const my_t&amp; lhs, const my_t&amp; rhs) noexcept    &#123;        return lhs.data &lt;=&gt; rhs.data;    &#125;&#125;auto foo()&#123;    mytest::my_t a&#123; 1 &#125;, b&#123; 2 &#125;;    return a &lt;=&gt; b; // 可以根据my_t所处的命名空间作用域找到operator&lt;=&gt;&#125;</code></pre><p>题外话的题外话：<br>对于形参，<code>my_t</code> 的拷贝开销很小，使用引用可能还不如使用拷贝方便高效，但是为了形式上的统一，我此处仍然使用<code>const T&amp;</code>形式。我相信在上述情况下(即给出的代码)，编译器最终的优化不会让这种“形式”影响程序的性能。<br>如果担心性能问题，请做性能测试(需要考虑是否可以启用编译器优化等条件)。  </p></div><hr><p>为我们的类型提供了三路比较运算符后，<br>若此函数被定义为<code>=default</code>，则C++会自动生成 <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code> 运算符。<br>若此函数定义不为<code>=default</code>，则C++会自动生成 <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code> 运算符。<br>这是三路比较运算符重载非常有用的一点，如果不需要自动生成的比较运算符可以显式弃置，如果自动生成的比较运算符不和自己的期望，也可以自定义它。  </p><p>注：提供<code>&lt;=&gt;</code>运算符的非默认实现(不定义为<code>=default</code>)后，c++ 不会为我们自动生成<code>==</code>运算符，至于为什么我不知道，有能力可以去翻阅相关提案。  </p><pre><code class="C++">// 示例class CX&#123;    int foo&#123;&#125;;    int bar&#123;&#125;;public:    auto operator &lt;=&gt; (const CX&amp;) const = default;    // 如果我们单不希望此类有 &quot;&gt;=&quot; 比较运算符，则显示弃置它：    bool operator &gt;= (const CX&amp;) const = delete; // 弃置 &gt;= 运算符    // 如果我们单希望 &quot;&gt;&quot; 运算符的比较方式是成员属性之和相比较，而不是根据三路比较运算自动生成的比较方式，则自定义它：    bool operator &gt; (const CX&amp; o) const noexcept    &#123;        return (this-&gt;foo + this-&gt;bar) &gt; (o.foo + o.bar);    &#125;&#125;;</code></pre><h3 id="默认的三路比较运算符重载"><a href="#默认的三路比较运算符重载" class="headerlink" title="默认的三路比较运算符重载"></a>默认的三路比较运算符重载</h3><p>当我们要为一个自定义类型提供三路比较运算符时，有时可以考虑采用默认的三路比较运算符。<br>默认的三路比较运算符返回值根据<a href="#ordering_cast">三种ordering的隐式转换规则</a>采取相应的类型。<br>即：有<code>std::partial_ordering</code>时为<code>std::partial_ordering</code>，否则有<code>std::weak_ordering</code>时为<code>std::weak_ordering</code>，否则为<code>std::strong_ordering</code>。<br>如果想要使用默认的三路比较运算符，类的成员必须全部满足：<strong>类型为基本类型</strong>或<strong>具有重载的返回值为<a href="#ordering_types">上述三种ordering</a>的三路比较运算符</strong>的类型。  </p><p>示例：</p><pre><code class="C++">// 成员函数形式：class CX1&#123;    int foo&#123;&#125;;    int bar&#123;&#125;; // memberspublic:    auto operator &lt;=&gt; (const CX1&amp;) const = default; // 返回类型为 strong_ordering&#125;;// 友元函数形式：class CX2&#123;    int foo&#123;&#125;;    double bar&#123;&#125;; // memberspublic:    friend auto operator &lt;=&gt; (const CX2&amp;, const CX2&amp;) = default; // 返回类型为 partial_ordering&#125;;class CX3&#123;    CX1 cx1&#123;&#125;;    CX2 cx2&#123;&#125;;public:    auto operator &lt;=&gt; (const CX1&amp;) const = default; // 返回类型为 partial_ordering&#125;;</code></pre><p>默认生成的三路比较运算符返回值取决于此：<br>按类中成员顺序进行三路比较，直到结果出现<code>less</code>、<code>greater</code>、<code>unordered</code>或全部比较完成，并将最后一个得到的结果作为整个三路比较运算的结果。</p><p>示例：</p><pre><code class="C++">#include &lt;iostream&gt;struct Test &#123;  int m1; double m2; bool m3; &#125;;int main()&#123;    using std::cout;    Test t1&#123; 1, 2.0, true &#125;;    Test t2&#123; 1, 3.0, false &#125;;    // 第一个成员属性比较结果为 equivalent, 继续    // 第二个成员属性比较结果为 less, 得到结果    if ((t1 &lt;=&gt; t2) &lt; 0) &#123; cout &lt;&lt; &quot;t1 &lt; t2 \n&quot;; &#125;    return 0;&#125;</code></pre><p>结果为</p><pre><code>t1 &lt; t2</code></pre><hr><p><a href="https://zh.cppreference.com/w/cpp/language/operator_comparison" title="zh cppreference operator_comparison">C++参考 | 比较运算符</a><br><a href="https://zh.cppreference.com/w/cpp/header/compare" title="zh cppreference compare">C++参考 | 标头 compare</a>  </p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
          <category> CPP20 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> CPP20 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 使用extern关键字声明全局常量的作用</title>
      <link href="/2023/09/18/CPP%E4%BD%BF%E7%94%A8extern%E5%85%B3%E9%94%AE%E5%AD%97%E5%A3%B0%E6%98%8E%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2023/09/18/CPP%E4%BD%BF%E7%94%A8extern%E5%85%B3%E9%94%AE%E5%AD%97%E5%A3%B0%E6%98%8E%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="#toolongtowatch">太长不看环节</a></p><h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>通常在编写大型C&#x2F;C++程序时，我们会用到分文件编写程序的方式组织代码，按照不同的功能模块(此模块非c++20模块)，将一份程序分成不同的部分。</p><p>为了让模块之间能够相互访问，需要将声明放在头文件(.h)中，将定义放在源文件(.c&#x2F;.cpp)中。</p><pre><code class="cpp">// header &quot;foo.h&quot;int foo();</code></pre><pre><code class="cpp">// source &quot;foo.cpp&quot;#include &quot;foo.h&quot;int foo()&#123;    return &#123;&#125;;&#125;</code></pre><p>这样，其他模块只要使用了预处理指令<code>#include &quot;foo.h&quot;</code>，就能使用函数<code>foo</code>了(<del>每个用到<code>foo</code>的源文件中，直接在使用之前声明一次也行</del>)。</p><pre><code class="cpp">// main.cpp#include &quot;foo.h&quot;int main()&#123;    return foo();&#125;</code></pre><hr><p>预处理指令<code>#include &quot;foo.h&quot;</code>的作用仅仅只是在预处理阶段使用”foo.h”文件的内容替换掉这条指令而已。</p><p>也就是说，编译器在编译”main.cpp”阶段，代码中只有孤零零一条声明：<code>int foo();</code>，而没有函数<code>foo</code>的定义，大家都不知道这个函数<code>foo</code>在哪里，也不知道这个函数<code>foo</code>干了什么，只知道有个叫<code>foo</code>的函数并且这里调用了函数<code>foo</code>。</p><p>虽然有些疑问，但是”main.cpp”还是被成功编译了，生成了一个”main.obj”(Windows平台)，<code>.obj</code>文件即”可重定位目标文件”，里面装满了编译器生成的目标代码。这时，”foo.cpp”也被编译了，生成了一个”foo.obj”文件……</p><p>现在来到了链接阶段，”main.cpp”中的<code>main</code>函数调用了<code>foo</code>函数，现在我们知道<code>foo</code>函数在”foo.obj”中，链接程序将它和<code>main</code>函数一并放入了”main.exe”(假设是这个名字)，并且在<code>main</code>函数中调用<code>foo</code>函数的地方填上了<code>foo</code>函数的位置。</p><p>这样，<code>main</code>函数就知道<code>foo</code>函数在哪了，当程序执行到此处时，<code>main</code>函数将把控制权交给<code>foo</code>，等着它将返回值交给<code>main</code>……</p><p>这就是小学生都知道的C&#x2F;C++语言从源码到可执行文件的流程。<del>当然，如果你照着上面写了然后还编译链接了，甚至还反编译了，甚至还一条条去看汇编指令了，最后发现<code>main</code>函数直接返回了0，说程序编译链接都是骗人的……别急，这可能是编译器将<code>foo</code>函数直接内联了，用代码替换了函数调用，这不是我们要讨论的内容。</del></p><p>一个内联的例子，用<code>mov eax, 5</code>替换了对函数foo的调用(Release模式下)。</p><img title="例子" src="inline_o.png" data-align="center"><h2 id="Extern-在声明全局变量时的作用"><a href="#Extern-在声明全局变量时的作用" class="headerlink" title="Extern 在声明全局变量时的作用"></a>Extern 在声明全局变量时的作用</h2><p>闹了半天主角”extern”都没出现，现在开始进入正题。</p><p>对函数进行分文件编写是呼吸一样平常的事情，而经常编写C&#x2F;C++程序的话，全局变量&#x2F;命名空间局部变量将是一个绕不开的东西。它也能像函数一样，将声明与定义分离。下面将进行展示~  </p><p>(使用MSVC)</p><pre><code class="cpp">// header &quot;bar.h&quot;extern int bar;</code></pre><pre><code class="cpp">// source &quot;bar.cpp&quot;int bar&#123; 123 &#125;;</code></pre><pre><code class="cpp">// main.cpp#include &quot;bar.h&quot;int main()&#123;    return bar;&#125;</code></pre><p>没错， <code>extern</code>关键字出现了，它告诉链接器这个叫<code>bar</code>的，等会去别的翻译单元中查找定义。通常情况下，非常量全局变量具有外部链接，如你所见，这个<code>bar</code>就是一个非常量全局变量，它具有外部链接，链接器让远在他<code>.obj</code>的<code>main</code>函数也能找到它。</p><hr><div id="toolongtowatch">我所熟知的情况到这就结束了，但是前几天，我在整理旧的代码的时候，发现了一个奇怪又熟悉的东西：</div><pre><code class="cpp">namespace Petal::UserEntrance&#123;    extern const fptr&lt;int&gt; pt_user_main&#123; &amp;::MainFunc &#125;;    extern const ptrc&lt;TChar&gt; pt_user_main_name&#123; Petal_TStr(#MainFunc) &#125;;&#125;</code></pre><p>在定义的时候出现了关键字<code>extern</code>，显然此时我已经忘记了<code>extern</code>在此处的作用，我抱着好奇的心态将它删了(指<code>extern</code>)，结果出现了链接错误：</p><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://learn.microsoft.com/zh-cn/cpp/error-messages/tool-errors/linker-tools-error-lnk2001">LNK2001</a></td><td>无法解析的外部符号 “int (__cdecl* Petal::UserEntrance::pt_user_main)(void)” (?pt_user_main@UserEntrance@Petal@@3Q6AHXZEA)</td></tr><tr><td><a href="https://learn.microsoft.com/zh-cn/cpp/error-messages/tool-errors/linker-tools-error-lnk2001">LNK2001</a></td><td>无法解析的外部符号 “wchar_t const * const Petal::UserEntrance::pt_user_main_name” (?pt_user_main_name@UserEntrance@Petal@@3QEB_WEB)</td></tr><tr><td><a href="https://learn.microsoft.com/zh-cn/cpp/error-messages/tool-errors/linker-tools-error-lnk1120">LNK1120</a></td><td>2 个无法解析的外部命令</td></tr></tbody></table><p>经典链接错误  </p><p><em>Classic</em>  </p><p>我忘记了当时为什么会这样写，查下MSDN。</p><p><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/extern-cpp?view=msvc-170">extern (C++) | Microsoft Learn | zh-cn</a></p><p><a href="https://learn.microsoft.com/en-us/cpp/cpp/extern-cpp?view=msvc-170">extern (C++) | Microsoft Learn | en-us</a></p><p>我果然是健忘的，故写下博客以便未来哪天犯傻了能快速找到之前的经验</p><img title="cat" src="my_cat.jpg" width="298" data-align="center"><p>也就是说，全局常量变量具有内部链接，即使在外声明也无法使用，除非在定义时在前面加上关键字<code>extern</code>。用<code>bar</code>来举例如下：</p><pre><code class="cpp">// header &quot;bar.h&quot;extern const int bar;</code></pre><pre><code class="cpp">// source &quot;bar.cpp&quot;extern const int bar&#123; 123 &#125;;</code></pre><pre><code class="cpp">// main.cpp#include &quot;bar.h&quot;int main()&#123;    return bar;&#125;</code></pre><hr><h2 id="VC-全局变量的链接"><a href="#VC-全局变量的链接" class="headerlink" title="VC++全局变量的链接"></a>VC++全局变量的链接</h2><p>既然都说到这份上，还是复习一下VC++中全局变量(及命名空间局部变量)所具有的链接(不包含C++20及更高标准的内容)。</p><p>仅内部链接：</p><ul><li><p>使用static声明的全局变量或命名空间局部变量</p></li><li><p>类型具有const限定 并且 先前没有外部链接的声明 的全局变量或命名空间局部变量</p></li><li><p>无名命名空间及其中的命名空间中的命名空间局部变量</p></li></ul><p>例</p><pre><code class="cpp">// test.cppstatic int foo&#123; 1 &#125;;const int bar&#123; 2 &#125;;namespace &#123; int unnamed&#123; 3 &#125;; &#125;</code></pre><pre><code class="cpp">// main.cppextern int foo;extern const int bar;extern int baz;int main()&#123;    int&#123; foo &#125;; // LNK2001    int&#123; bar &#125;; // LNK2001    int&#123; baz &#125;; // LNK2001    return 0;&#125;</code></pre><p>外部链接(不在无名命名空间及其中的命名空间内定义的情况)：</p><ul><li><p>使用extern声明的全局变量或命名空间局部变量</p></li><li><p>没有const限定的全局变量或命名空间局部变量</p></li></ul><p>例</p><pre><code class="cpp">// test.cppextern const int foo&#123; 1 &#125;;int bar&#123; 2 &#125;;extern const int baz;const int baz&#123; 3 &#125;;</code></pre><pre><code class="cpp">// main.cppextern const int foo;extern int bar;extern const int baz;int main()&#123;    int&#123; foo &#125;;    int&#123; bar &#125;;    int&#123; baz &#125;;    return 0;&#125;</code></pre><p>值得注意的是，C++引用忽略限定符，所以如下也能通过编译链接(MSVC)：</p><pre><code class="cpp">// test.cppint val&#123; 100 &#125;;int const/*此const限定int*/ &amp;const/*此const无效*/ test&#123; val &#125;;</code></pre><pre><code class="cpp">extern const int&amp; const test;int main()&#123;    int&#123; test &#125;;    return 0;&#125;</code></pre><p>但请不要这么编写代码。</p><p>更复杂的例子(其实分清顶层const和底层const的区别就不会被const限定迷惑住了)</p><pre><code class="cpp">// test.cppint* ptr1&#123; nullptr &#125;; // 外部链接const int* ptrc1&#123; nullptr &#125;; // 外部链接int *const cptr1&#123; nullptr &#125;; // 内部链接int const* const cptrc1&#123; nullptr &#125;; // 内部链接int const* const&amp; cptrcr1&#123; cptrc1 &#125;; // 外部链接extern int const* const cptrc2&#123; nullptr &#125;; // 外部链接</code></pre><p>C++参考</p><p><a href="https://zh.cppreference.com/w/cpp/language/storage_duration">存储类说明符 - cppreference.com</a></p><p><a href="https://en.cppreference.com/w/cpp/language/storage_duration">Storage class specifiers - cppreference.com</a></p><hr><p>完结！</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
          <category> 猝不及防系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 令我猝不及防的CPP_MSVC知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
