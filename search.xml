<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>烦人的 C4819 警告</title>
      <link href="/2024/09/13/Annoying-Warning-C4819/"/>
      <url>/2024/09/13/Annoying-Warning-C4819/</url>
      
        <content type="html"><![CDATA[<p>随着 Windows 对 utf-8 的支持逐渐完善（不需要 bom 记事本也能分辨 utf-8 和所谓 “ANSI” 编码的文本文件），我现在基本都会使用 utf-8 作为 C++ 源文件的编码。但是 <code>CL.EXE</code> 却不行，它把不带 bom 的源文件当 “ANSI” 编码的文本来处理，我的代码页为 936，即 GBK，导致存在非 ASCII 字符时出现 <a href="https://learn.microsoft.com/zh-cn/cpp/error-messages/compiler-warnings/compiler-warning-level-1-c4819?view=msvc-170" title="MSDN zh-cn">C4819</a> 警告。  </p><p>下面是一些常见的解决方法：  </p><p>分类一：迁就文件  </p><ol><li>在使用 <code>CL.EXE</code> 编译时添加参数 <code>/utf-8</code> 非常好使，<br>如果是通过 VS 使用 <code>CL.EXE</code> 编译，在 <code>项目-&gt;属性-&gt;配置属性-&gt;C/C++-&gt;命令行-&gt;其他选项</code> 里添加 <code>/utf-8</code> 就行；  </li><li>把系统的代码页改成 65001，即 utf-8，<br>这就需要你开启那个狗屎 beta 功能“全局 utf-8” 了，我开了之后，<code>.chm</code> 文件打不开了，以前的文本文件也乱码了，如果没有历史负担，可以开，但我用了一段时间就换回去了💩💩💩。</li></ol><p>分类二：迁就系统</p><ol><li>把 utf-8 的源文件转为 “带 BOM 的 utf-8” 文件，这样 <code>CL.EXE</code> 才没意见💩；  </li><li>把 utf-8 的源文件转为 “ANSI” 编码，比如用记事本打开另存为 “ANSI” 编码的文件💩💩💩；  </li><li>修改源文件里冲突的部分，比如字符串里写了个 emoji <code>&quot;💩&quot;</code>，用通用字符名 <code>&quot;\U0001F4A9&quot;</code> 替换它，可读性直线下降。</li></ol><p>我遇到的问题是什么呢，我的源文件准备只用 ASCII，这样利用 utf-8 对 ASCII 的兼容性，可以无需改变任何事也能在我的环境里无警告通过编译。等到我写好，编译器说我某个文件 <code>xxx.h</code> 里有不兼容的字符，叫我保存成 Unicode 文本文件，但是给的位置是错误的 “1 行 1 列”。  </p><p>无奈只能自己找，代码比较多我看了半天都没发现哪有非 ASCII 字符💩💩💩。  </p><p>最后的解决方案，写个程序把源文件按字节读出，如果有数值大于 127 的字节就报告偏移量，最后发现在偏移量 598 处有一个全角冒号出现在了注释里，修改它，解决。  </p><p>💩</p><p>复现：  </p><img src="img.png" data-align="center">]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 严格弱序</title>
      <link href="/2024/03/26/CPP-Strict-Weak-Order/"/>
      <url>/2024/03/26/CPP-Strict-Weak-Order/</url>
      
        <content type="html"><![CDATA[<img src="img.jpg" alt="C++ Primer 5th" data-align="center"><p>怀疑书上表达有误，若以“小于等于”为例，第一条就令所有整型值和浮点型值内建的<code>&lt;=</code>运算无法满足。  </p><p>对于二元关系 <code>less</code>：  </p><ul><li>若 <code>less(a, b)</code> 为真，则 <code>less(b, a)</code> 为假，即不满足自反性。  </li><li>若 <code>less(a, b)</code> 和 <code>less(b, c)</code> 为真，蕴含 <code>less(a, c)</code> 为真，即满足传递性。  </li><li>令关系 <code>equal(a, b)</code> 为 <code>(¬less(a, b) ∧ ¬less(b, a))</code>，可知 <code>equal</code> 是 <code>a</code> 与 <code>b</code> 的等价关系，且同样具有传递性。</li></ul><p><a href="https://zh.cppreference.com/w/cpp/concepts/strict_weak_order">C++参考</a>  </p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 完美转发的实现</title>
      <link href="/2024/03/19/CPP-Implementation-of-forward/"/>
      <url>/2024/03/19/CPP-Implementation-of-forward/</url>
      
        <content type="html"><![CDATA[<h1 id="C-完美转发的实现"><a href="#C-完美转发的实现" class="headerlink" title="C++ 完美转发的实现"></a>C++ 完美转发的实现</h1><p>本文将介绍 <code>std::forward</code> 怎样做到“完美转发”及如何实现。<br>如有错误请指出，感激不尽。  </p><p>讲完美转发前需要先了解转发引用和引用折叠。  </p><h2 id="转发引用"><a href="#转发引用" class="headerlink" title="转发引用"></a>转发引用</h2><p>在函数模板中，为了可以根据传入参数的值类别，使形参的类型为相应的左值引用&#x2F;右值引用，我们通常使用转发引用，也称为万能引用：  </p><pre><code class="C++">template &lt;typename T&gt;void foo(T&amp;&amp; arg) &#123;&#125;</code></pre><p>对 C++20 新增的简写函数模板也是如此：  </p><pre><code class="C++">void foo(auto&amp;&amp; arg) &#123;&#125;</code></pre><p>下面的调用中：  </p><pre><code class="C++">foo(1);int num&#123; 1 &#125;;foo(num);</code></pre><p>对于 <code>foo(1)</code>，形参 <code>arg</code> 的类型是 <code>int&amp;&amp;</code>；对于 <code>foo(num)</code>，形参 <code>arg</code> 的类型是 <code>int&amp;</code>。这都是用引用折叠来实现的。  </p><p>虽然 <code>T&amp;&amp;</code> 看上去是右值引用的形式，但是需要考虑 <code>T</code> 是引用类型的别名或是需要被推导的类型的情况，请看“引用折叠”。</p><h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>C++ 不允许引用的引用，如 <code>int &amp; &amp; r = num;</code> <code>int &amp; &amp;&amp; r = 1;</code>……<br>这些都无法通过编译。  </p><p>但是当 <code>T</code> 是引用类型的类型别名时，使用 <code>T&amp;</code> 和 <code>T&amp;&amp;</code> 将发生引用折叠（这是特性）。  </p><pre><code class="C++">using T = int&amp;;using U = int&amp;&amp;;int num&#123;&#125;;T&amp;  r1 = num;T&amp;&amp; r2 = num;U&amp;  r3 = num;U&amp;&amp; r4 = 0;</code></pre><p>引用折叠的规则：<code>&amp;&amp; &amp;&amp;</code> 折叠成右值引用，所有其他组合均折叠成左值引用。  </p><p>就以上代码，运用上述规则进行推导，得出：  </p><table><thead><tr><th align="center">标识符</th><th>类型声明</th><th>替换类型别名后</th><th align="center">引用折叠后的类型</th></tr></thead><tbody><tr><td align="center">r1</td><td>T&amp;</td><td>int&amp; &amp;</td><td align="center">int&amp;</td></tr><tr><td align="center">r2</td><td>T&amp;&amp;</td><td>int&amp; &amp;&amp;</td><td align="center">int&amp;</td></tr><tr><td align="center">r3</td><td>U&amp;</td><td>int&amp;&amp; &amp;</td><td align="center">int&amp;</td></tr><tr><td align="center">r4</td><td>U&amp;&amp;</td><td>int&amp;&amp; &amp;&amp;</td><td align="center">int&amp;&amp;</td></tr></tbody></table><p>除了类型别名，使用 <code>模板参数&amp;&amp;</code> 和 <code>auto&amp;&amp;</code> 也能发生引用折叠：  </p><pre><code class="C++">template &lt;typename T&gt;void foo(T&amp;&amp; arg) // T&amp;&amp; 在接受左值时将发生引用折叠&#123;    std::vector&lt;int&gt; vec&#123; 1, 2, 3 &#125;;    for (auto&amp;&amp; e : vec) // auto&amp;&amp; 同上    &#123;        std::cout &lt;&lt; e &lt;&lt; &#39; &#39;;    &#125;&#125;</code></pre><p>至于模板参数T和auto如何被推导为引用类型而引发引用折叠，请看下节。  </p><h2 id="模板参数的类型推导"><a href="#模板参数的类型推导" class="headerlink" title="模板参数的类型推导"></a>模板参数的类型推导</h2><p>还是以 <code>foo</code> 函数模板为例，为了使 <code>foo</code> 接收拥有不同值类别的参数并且使形参的类型为相应引用，如何推导模板参数 <code>T</code> 的类型？  </p><pre><code class="C++">template &lt;typename T&gt;void foo(T&amp;&amp; arg) &#123;&#125;void test(int num)&#123;    foo(1);    foo(num);&#125;</code></pre><p><code>foo(1)</code> 中，实参 <code>1</code> 是纯右值，形参 <code>T&amp;&amp; arg</code> 中，arg只能是右值引用(因为无法将左值引用绑定到右值)，<code>T</code> 被推导为 <code>int</code>，<code>T&amp;&amp;</code> 刚好是 <code>int&amp;&amp;</code>；<br><code>foo(num)</code> 中， 实参 <code>num</code> 是左值，形参 <code>T&amp;&amp; arg</code> 中，arg只能是左值引用(因为无法将右值引用绑定到左值)，<code>T</code> 被推导为 <code>int&amp;</code>，<code>T&amp;&amp;</code> 则是 <code>int&amp; &amp;&amp;</code>，引用折叠为 <code>int&amp;</code>。  </p><p>此外，<code>auto</code> 使用和模板参数一样的推导规则。  </p><p>类型推导和引用折叠双剑合璧，就使之成为转发引用。  </p><p>转发引用使用引用折叠，根据实参的值类别使形参为左值引用或右值引用，那么为什么需要完美转发呢？请看下节。  </p><h2 id="需要完美转发的原因"><a href="#需要完美转发的原因" class="headerlink" title="需要完美转发的原因"></a>需要完美转发的原因</h2><p>上节提到左值引用只能绑定到左值，右值引用只能绑定到右值。值类别是个需要严肃讨论的东西，但是本文主题不在于此，关于值类别，不同于传统 C 语言，C++11 给出的定义，参考<a href="https://en.cppreference.com/w/cpp/language/value_category" title="value_category - 值类别">C++ Reference</a>(<a href="https://zh.cppreference.com/w/cpp/language/value_category" title="c++ reference 值类别(中文)">中文</a>)。  </p><p>值类别通常用于拷贝控制，因此在一些场景中，我们需要转发操作。<br>注：id 表达式的值类别都是左值，无论这个标识符表达式的类型是左值引用还是右值引用。  </p><p>例：  </p><pre><code class="C++">template &lt;typename T&gt;void no_forwarding(T&amp;&amp; arg)&#123;    ...    // 这行代码之后不再使用 arg    // 如果 arg 的类型是右值引用，我们希望使用移动构造    // 如果 arg 的类型是左值引用，我们希望使用拷贝构造    // 但是这里无论如何都会匹配到拷贝构造，因为 id 表达式的值类别是左值    // 为了达成我们期望的效果，我们需要一个转发操作    using arg_t = std::remove_reference_t&lt;T&gt;;    arg_t temp&#123; arg &#125;;    ...&#125;</code></pre><pre><code class="C++">template &lt;typename T&gt;void use_forwarding(T&amp;&amp; arg)&#123;    ...    // arg 的类型是右值引用时 std::forward&lt;T&gt;(arg) 这个表达式是右值，匹配移动构造；    // 反之则是左值，使用拷贝构造。    using arg_t = std::remove_reference_t&lt;T&gt;;    arg_t temp&#123; std::forward&lt;T&gt;(arg) &#125;;    ...&#125;</code></pre><p>故虽然转发引用有用，但我们还需要一个转发操作，才算得上健全。<br>解决方案请看下节，完美转发。  </p><p>如果你分不清类型和值类别（比如想问“为什么右值引用不是右值”这种问题），请去看一下<a href="https://zh.cppreference.com/w/cpp/language/value_category">cpp reference</a>。  </p><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>为制造一个右值，我们可以使用 <code>std::move</code>，<code>std::move</code> 接收一个左值或右值，并返回一个右值。  </p><p>一般 <code>std::move</code> 的实现：  </p><pre><code class="C++">// C++14template &lt;typename T&gt;constexpr remove_reference_t&lt;T&gt;&amp;&amp; move(T&amp;&amp; arg) noexcept&#123;    return static_cast&lt;remove_reference_t&lt;T&gt;&amp;&amp;&gt;(arg);&#125;</code></pre><p>从 <code>std::move</code> 源码可以看出，它实际是使用 <code>static_cast</code> 实现的。<br>对于持有 <code>int</code> 类型的左值 <code>num</code>，<code>static_cast&lt;int&amp;&amp;&gt;(num)</code> 将左值转换为右值。使用 <code>static_cast</code> 需要我们显式填入类型，<code>std::move(num)</code> 则不需要，更加简短方便。  </p><p>若函数返回类型是右值引用，那么这个函数调用表达式的值类别是右值；若函数返回类型是左值引用，那么这个函数调用表达式的值类别是左值。<br>(若函数返回值类型不是引用，那么函数调用表达式的值类别是右值)  </p><p>回顾<a href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">类型推导小节</a>，我们同样以  </p><pre><code class="C++">template &lt;typename T&gt;void foo(T&amp;&amp; arg)&#123;    using arg_t = std::remove_reference_t&lt;T&gt;;    if constexpr (std::is_same_v&lt;T, int&amp;&gt;)    &#123;        arg_t temp&#123; arg &#125;; // copy    &#125;    else // T = int, decltype(arg) = int&amp;&amp;    &#123;        arg_t temp&#123; std::move(arg) &#125;; // move    &#125;&#125;void test()&#123;    int num = 1;    foo(1);    foo(num);&#125;</code></pre><p>为例，对于 <code>foo(1)</code>，形参 <code>arg</code> 有类型 <code>int&amp;&amp;</code>，<code>T</code> 为 <code>int</code>；对于 <code>foo(num)</code>，形参 <code>arg</code> 有类型 <code>int&amp;</code>，<code>T</code> 为 <code>int&amp;</code>。  </p><p>有以上信息帮助，我们就能分辨出哪些情况应该使用 <code>std::move</code> 或 <code>static_cast</code> 将 <code>arg</code> 制作成右值，但是手动选择何时使用 <code>std::move</code> 过于麻烦，我们应该有一个函数模板，根据以上信息返回左值或右值，那就是 <code>std::forward</code>。  </p><p>我们可以实现一个为左值服务的 <code>my_forward</code>，让它具有 <code>std::forward</code> 的基本功能。  </p><p>对于 <code>my_forward</code>，<code>foo</code> 的模板参数 <code>T</code> 或形参的类型 <code>decltype(arg)</code> 是有用的信息；<br>为了使用我们需要的信息，<code>my_forward</code> 应该是一个模板，令模板参数列表为 <code>&lt;typename T&gt;</code>，并且在使用 <code>my_forward</code> 时，显式填入模板参数，不能使用类型推导；<br>使用引用折叠来处理返回类型；<br>返回语句同样需要引用折叠配合 <code>static_cast</code> 来处理成正确的值类别，令返回值能够绑定到它。  </p><p><code>my_forward</code> 的实现如下：  </p><pre><code class="C++">template &lt;typename T&gt;constexpr T&amp;&amp; my_forward(std::remove_reference_t&lt;T&gt;&amp; arg) noexcept&#123;    return static_cast&lt;T&amp;&amp;&gt;(arg);&#125;</code></pre><p>测试：  </p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;type_traits&gt;template &lt;typename T&gt;constexpr T&amp;&amp; my_forward(std::remove_reference_t&lt;T&gt;&amp; arg) noexcept&#123;    return static_cast&lt;T&amp;&amp;&gt;(arg);&#125;struct test&#123;    test()&#123; std::cout &lt;&lt; &quot;default constructor\n&quot;; &#125;    test(test&amp;) &#123; std::cout &lt;&lt; &quot;copy\n&quot;; &#125;    test(test&amp;&amp;) &#123; std::cout &lt;&lt; &quot;move\n&quot;; &#125;&#125;;template &lt;typename T&gt;void forward_test(T&amp;&amp; arg)&#123;    using arg_t = std::remove_reference_t&lt;T&gt;;    arg_t temp&#123; my_forward&lt;T&gt;(arg) &#125;;&#125;int main()&#123;    test foo&#123;&#125;; // default constructor    forward_test(foo); // copy    forward_test(std::move(foo)); // move&#125;</code></pre><p>成功实现完美转发(<a href="https://godbolt.org/z/8qbToznbd">godbolt</a>)！  </p><p>根据引用折叠的知识，我们来推演一下 <code>forward_test</code> 的 <code>arg</code> 分别有类型 <code>int&amp;</code> 和 <code>int&amp;&amp;</code> 时，<code>my_forward</code> 的工作状况：  </p><h3 id="arg-为左值引用时"><a href="#arg-为左值引用时" class="headerlink" title="arg 为左值引用时"></a>arg 为左值引用时</h3><p>已知当 <code>arg</code> 为 <code>int&amp;</code> 时，<code>T</code> 也为 <code>int&amp;</code>，<br>将 <code>T</code> 填入后 <code>my_forward&lt;T&gt;(arg)</code> 即是 <code>my_forward&lt;int&amp;&gt;(arg)</code>。<br>再来看 <code>my_forward</code> 的处理：<br>返回值类型 <code>T&amp;&amp;</code> 即是 <code>int&amp; &amp;&amp;</code>，引用折叠后为 <code>int&amp;</code>，<br>参数是 <code>std::remove_reference_t&lt;T&gt;&amp; arg</code>，经处理后是 <code>int &amp; arg</code>，<br>返回语句 <code>return static_cast&lt;T&amp;&amp;&gt;(arg);</code> 即是 <code>return static_cast&lt;int&amp; &amp;&amp;&gt;(arg);</code>，引用折叠后为 <code>return static_cast&lt;int&amp;&gt;(arg);</code>，<br>成功转发为左值。  </p><h3 id="arg-为右值引用时"><a href="#arg-为右值引用时" class="headerlink" title="arg 为右值引用时"></a>arg 为右值引用时</h3><p>已知当 <code>arg</code> 为 <code>int&amp;&amp;</code> 时，<code>T</code> 为 <code>int</code>，<br>将 <code>T</code> 填入后 <code>my_forward&lt;T&gt;(arg)</code> 即是 <code>my_forward&lt;int&gt;(arg)</code>。<br>再来看 <code>my_forward</code> 的处理：<br>返回值类型 <code>T&amp;&amp;</code> 即是 <code>int&amp;&amp;</code>，<br>参数是 <code>std::remove_reference_t&lt;T&gt;&amp; arg</code>，经处理后是 <code>int &amp; arg</code>，<br>返回语句 <code>return static_cast&lt;T&amp;&amp;&gt;(arg);</code> 即是 <code>return static_cast&lt;int&amp;&amp;&gt;(arg);</code>，<br>成功转发为右值。  </p><h2 id="完美转发·续"><a href="#完美转发·续" class="headerlink" title="完美转发·续"></a>完美转发·续</h2><p>标准库还提供了为右值服务的 <code>std::forward</code>，以 msvc-stl为例：  </p><pre><code class="C++">_EXPORT_STD template &lt;class _Ty&gt;_NODISCARD _MSVC_INTRINSIC constexpr _Ty&amp;&amp; forward(remove_reference_t&lt;_Ty&gt;&amp;&amp; _Arg) noexcept &#123;    static_assert(!is_lvalue_reference_v&lt;_Ty&gt;, &quot;bad forward call&quot;);    return static_cast&lt;_Ty&amp;&amp;&gt;(_Arg);&#125;</code></pre><p>可以看到为右值提供的 <code>std::forward</code> 不允许将右值转发为左值！  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++20 的比较运算符</title>
      <link href="/2024/02/22/CPP20-Comparison-Operators/"/>
      <url>/2024/02/22/CPP20-Comparison-Operators/</url>
      
        <content type="html"><![CDATA[<p>在 C++20 中，比较运算符们迎来了一次革新，不仅有三路比较运算符的加入，还有重载决议上的改变。<br>C++20 中添加了比较运算符的特殊重载解析规则。  </p><p>关于三路比较运算符的使用方法可以查看<a href="https://sunflavourpetals.github.io/2023/09/22/CPP20%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/">我的博客</a>。  </p><p>在 C++20 之前，若要支持所有的比较运算符，一般需要提供：  </p><ol><li><code>operator==</code>  </li><li><code>operator!=</code>  </li><li><code>operator&lt;</code>  </li><li><code>operator&lt;=</code>  </li><li><code>operator&gt;</code>  </li><li><code>operator&gt;=</code></li></ol><p>从 C++20 起，一般只需要提供：  </p><ol><li><code>operator==</code>  </li><li><code>operator&lt;=&gt;</code></li></ol><p><code>!=</code> 可以通过重载决议选择到使用 <code>operator==</code> 的方式；  </p><p><code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code> 可以通过重载决议选择到使用 <code>operator&lt;=&gt;</code> 的方式。  </p><p>这极大地缩减了为用户自定义类型提供比较操作的成本，<br>此外，若 <code>operator&lt;=&gt;</code> 被定义为 <code>=default</code>，那么 <code>==</code>、<code>!=</code> 也将可用：  </p><pre><code class="C++">struct Foo&#123;    int data&#123;&#125;;    friend auto operator&lt;=&gt;(Foo, Foo) = default;&#125;;// 仅仅这样就能对 Foo 类型对象使用任意比较操作</code></pre><p>示例 <a href="https://godbolt.org/z/6a3nfjcPW">godbolt</a>：  </p><pre><code class="C++">#include &lt;iostream&gt;struct A&#123;    int a&#123;&#125;;    auto operator==(A aa)    &#123;        std::cout &lt;&lt; &quot;my A==&quot; &lt;&lt; &quot;\n&quot;;        return a == aa.a;    &#125;    auto operator&lt;=&gt;(A aa)    &#123;        std::cout &lt;&lt; &quot;my A&lt;=&gt;&quot; &lt;&lt; &quot;\n&quot;;        return a &lt;=&gt; aa.a;    &#125;&#125;;int main()&#123;    A a1&#123; 1 &#125;, a2&#123; 1 &#125;;    std::cout &lt;&lt; std::boolalpha;    std::cout &lt;&lt; &quot;==: &quot;  &lt;&lt; (a1 == a2) &lt;&lt; &quot;\n&quot;;    std::cout &lt;&lt; &quot;!=: &quot;  &lt;&lt; (a1 != a2) &lt;&lt; &quot;\n&quot;;    std::cout &lt;&lt; &quot;&lt;=&gt;: &quot; &lt;&lt; ((a1 &lt;=&gt; a2) == 0 ? &quot;eq&quot; : &quot;not eq&quot;) &lt;&lt; &quot;\n&quot;;    std::cout &lt;&lt; &quot;&gt;: &quot;   &lt;&lt; (a1 &gt; a2)  &lt;&lt; &quot;\n&quot;;    std::cout &lt;&lt; &quot;&gt;=: &quot;  &lt;&lt; (a1 &gt;= a2) &lt;&lt; &quot;\n&quot;;    std::cout &lt;&lt; &quot;&lt;: &quot;   &lt;&lt; (a1 &lt; a2)  &lt;&lt; &quot;\n&quot;;    std::cout &lt;&lt; &quot;&lt;=: &quot;  &lt;&lt; (a1 &lt;= a2) &lt;&lt; &quot;\n&quot;;&#125;</code></pre><pre><code class="output">==: my A==true!=: my A==false&lt;=&gt;: my A&lt;=&gt;eq&gt;: my A&lt;=&gt;false&gt;=: my A&lt;=&gt;true&lt;: my A&lt;=&gt;false&lt;=: my A&lt;=&gt;true</code></pre><h3 id="比较运算符的特殊重载解析规则"><a href="#比较运算符的特殊重载解析规则" class="headerlink" title="比较运算符的特殊重载解析规则"></a>比较运算符的特殊重载解析规则</h3><p>在 C++20 之前，如果只有 <code>operator==(A, int)</code> 那么只有 <code>a == 123</code> 这种比较方式能够通过编译，从 C++20 起，此情况上 <code>123 == a</code> 将被视为 <code>a == 123</code>，重载决议选择最佳候选为 <code>operator==(A, int)</code>;  </p><p>如果有 <code>operator==(A, int)</code>、<code>operator==(A, A)</code>、<code>A::A(int)</code>(A的非 explicit 构造函数)，<code>123 == a</code> 将被视为 <code>a == 123</code>，重载决议选择最佳候选为 <code>operator==(A, int)</code>，在 C++20 前，这个操作将被解释为从字面量 <code>123</code> 构造 <code>A</code> 对象，再选择 <code>operator==(A, A)</code> 进行比较操作；  </p><p>如果有 <code>A::operator==(int)</code>、<code>A::operator==(A)</code>、<code>A::A(int)</code>(A的非 explicit 构造函数)，<code>123 == a</code> 将被视为 <code>a == 123</code>，重载决议选择最佳候选 <code>A::operator==(int)</code>，在 C++20 前，这个操作无法通过编译。  </p><p>示例 <a href="https://godbolt.org/z/s8ddG873h">godbolt</a>：  </p><pre><code class="C++">#include &lt;iostream&gt;struct A&#123;    int a&#123;&#125;;    A() = default;    A(int i) : a&#123; i &#125; &#123;&#125;    auto operator==(A aa)    &#123;        std::cout &lt;&lt; &quot;my A==A&quot; &lt;&lt; &quot;\n&quot;;        return a == aa.a;    &#125;    auto operator==(int i)    &#123;        std::cout &lt;&lt; &quot;my A==int&quot; &lt;&lt; &quot;\n&quot;;        return a == i;    &#125;&#125;;int main()&#123;    A a1&#123; 1 &#125;, a2&#123; 1 &#125;;    std::cout &lt;&lt; std::boolalpha;        std::cout &lt;&lt; (a1 == 1) &lt;&lt; &quot;\n&quot;;    std::cout &lt;&lt; (1 == a2) &lt;&lt; &quot;\n&quot;; // error before c++20&#125;</code></pre><pre><code class="output">my A==inttruemy A==inttrue</code></pre><p>此操作会受 <code>operator!=</code> 定义的影响，阅读下方C++草案 12.2.2.3.4 部分了解。  </p><p>还有下面这个例子 <a href="https://godbolt.org/z/zo4qvMb1E">godbolt</a>：  </p><pre><code class="C++">#include &lt;iostream&gt;struct A&#123;    int a&#123;&#125;;    A() = default;    A(int aa) : a&#123; aa &#125; &#123;&#125;    auto operator==(A aa)    &#123;        std::cout &lt;&lt; &quot;my A==&quot; &lt;&lt; &quot;\n&quot;;        return a == aa.a;    &#125;    auto operator&lt;=&gt;(A aa)    &#123;        std::cout &lt;&lt; &quot;my A&lt;=&gt;&quot; &lt;&lt; &quot;\n&quot;;        return a &lt;=&gt; aa.a;    &#125;    auto operator&lt;(A aa)    &#123;        std::cout &lt;&lt; &quot;my A&lt;&quot; &lt;&lt; &quot;\n&quot;;        return a &lt; aa.a;    &#125;&#125;;int main()&#123;    A a1&#123;&#125;, a2&#123;&#125;;    (void)(123 == a2);    (void)(123 != a2);    (void)(123 &lt;=&gt; a2);    (void)(123 &gt; a2);    (void)(123 &gt;= a2);    (void)(123 &lt; a2); // 最佳匹配是 A::operator&lt;=&gt;(A) 注：reversed                      // 0 &lt; (a2 &lt;=&gt; 123)                      // 0 &lt; (a2 &lt;=&gt; A&#123; 123 &#125;)    (void)(123 &lt;= a2);    (void)(a1 &lt; 123); // 最佳匹配是 A::operator&lt;(A)                      // a1 &lt; A&#123; 123 &#125;    (void)(a1 &lt; a2);  // 最佳匹配是 A::operator&lt;(A)&#125;</code></pre><pre><code class="output">my A==my A==my A&lt;=&gt;my A&lt;=&gt;my A&lt;=&gt;my A&lt;=&gt;my A&lt;=&gt;my A&lt;my A&lt;</code></pre><p>阅读下方C++草案 12.2.2.3.9 部分了解。  </p><p>从某种意义上讲，<code>lhs op rhs</code> 和 <code>operator op(lhs, rhs)</code> 的不同之处又增加了，如果 <code>op</code> 实际上是 <code>operator==</code> 或 <code>operator&lt;=&gt;</code> 经特殊处理而来，而不是被s声明的运算符重载函数，那么使用后者的形式应该会得到一个调用未声明函数的错误(<a href="https://godbolt.org/z/jrEq91WG9">godbolt</a>)。  </p><h3 id="C-草案摘录"><a href="#C-草案摘录" class="headerlink" title="C++草案摘录"></a>C++草案摘录</h3><blockquote><p>12.2.2.3 Operators in expressions  </p><p>…  </p><p>4  </p><p>A non-template function or function template F named operator&#x3D;&#x3D; is a rewrite target with first operand o unless a search for the name operator!&#x3D; in the scope S from the instantiation context of the operator expression finds a function or function template that would correspond ([basic.scope.scope]) to F if its name were operator&#x3D;&#x3D;, where S is the scope of the class type of o if F is a class member, and the namespace scope of which F is a member otherwise. A function template specialization named operator&#x3D;&#x3D; is a rewrite target if its function template is a rewrite target.<br>[Example 2:  </p><pre><code class="C++">struct A &#123;&#125;;  template&lt;typename T&gt; bool operator==(A, T);     // #1  bool a1 = 0 == A();                             // OK, calls reversed #1  template&lt;typename T&gt; bool operator!=(A, T);  bool a2 = 0 == A();                             // error, #1 is not a rewrite target   struct B &#123;      bool operator==(const B&amp;);    // #2  &#125;;  struct C : B &#123;      C();      C(B);      bool operator!=(const B&amp;);    // #3  &#125;;bool c1 = B() == C();           // OK, calls #2; reversed #2 is not a candidate// because search for operator!= in C finds #3bool c2 = C() == B();           // error: ambiguous between #2 found when searching C and                                // reversed #2 found when searching Bstruct D &#123;&#125;;template&lt;typename T&gt; bool operator==(D, T);       // #4inline namespace N &#123;    template&lt;typename T&gt; bool operator!=(D, T);   // #5&#125;bool d1 = 0 == D();             // OK, calls reversed #4; #5 does not forbid #4 as a rewrite target</code></pre><p>— end example]  </p><p>…  </p><p>9  </p><p>If a rewritten operator&lt;&#x3D;&gt; candidate is selected by overload resolution for an operator @, x @ y is interpreted as 0 @ (y &lt;&#x3D;&gt; x) if the selected candidate is a synthesized candidate with reversed order of parameters, or (x &lt;&#x3D;&gt; y) @ 0 otherwise, using the selected rewritten operator&lt;&#x3D;&gt; candidate. Rewritten candidates for the operator @ are not considered in the context of the resulting expression.  </p><p>10  </p><p>If a rewritten operator&#x3D;&#x3D; candidate is selected by overload resolution for an operator @, its return type shall be cv bool, and x @ y is interpreted as:<br>(10.1)<br>if @ is !&#x3D; and the selected candidate is a synthesized candidate with reversed order of parameters, !(y &#x3D;&#x3D; x),<br>(10.2)<br>otherwise, if @ is !&#x3D;, !(x &#x3D;&#x3D; y),<br>(10.3)<br>otherwise (when @ is &#x3D;&#x3D;), y &#x3D;&#x3D; x,<br>in each case using the selected rewritten operator&#x3D;&#x3D; candidate.  </p></blockquote><p><a href="https://eel.is/c++draft/over.match">完整 C++ 草案</a>  </p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
          <category> CPP20 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> CPP20 </tag>
            
            <tag> 猝不及防系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSDN中Direct2D快速入门页面中的疏漏</title>
      <link href="/2024/02/12/Omissions-in-MSDN-Getting-Started-with-Direct2d/"/>
      <url>/2024/02/12/Omissions-in-MSDN-Getting-Started-with-Direct2d/</url>
      
        <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>MSDN文章<a href="https://learn.microsoft.com/zh-cn/windows/win32/direct2d/getting-started-with-direct2d#step-5-draw-the-rectangle">Direct2D快速入门-步骤 5：绘制矩形</a>中给出的代码如下：  </p><pre><code class="C++">pRT-&gt;BeginDraw();pRT-&gt;DrawRectangle(    D2D1::RectF(        rc.left + 100.0f,        rc.top + 100.0f,        rc.right - 100.0f,        rc.bottom - 100.0f),        pBlackBrush);HRESULT hr = pRT-&gt;EndDraw();</code></pre><p>此处调用 <code>ID2D1HwndRenderTarget::BeginDraw</code> 后没有使用 <code>ID2D1HwndRenderTarget::Clear</code> 成员函数执行清屏操作，并且我们创建的画笔是黑色画笔。在将上述代码放进 <code>case WM_PAINT:</code> 后，在我的电脑上渲染效果是一片漆黑：  </p><img src="display_bug.png" alt="效果图" data-align="center">  <p>加上清屏操作即可：  </p><img src="display.png" alt="效果图" data-align="center">  <p>在<a href="https://learn.microsoft.com/zh-cn/windows/win32/direct2d/direct2d-quickstart#part-4-render-direct2d-content">创建简单的 Direct2D 应用程序 - 第4部分：呈现 Direct2D 内容 - 4.</a> 这部分内容中，则提到了清屏操作。除了清屏，还有在 <code>ID2D1HwndRenderTarget::EndDraw</code> 后调用 <code>ValidateRect</code> 函数阻止系统持续生成 <code>WM_PAINT</code> 消息等。  </p><p>此外，在拖拽窗口时渲染的画面有闪烁现象，阻止 <code>WM_ERASEBKGND</code> 消息的默认处理即可避免：  </p><pre><code class="C++">class D2DWindow : public Petal::Window&#123;public:    Petal::win32lres Process(        Petal::win32msg  message,         Petal::win32wprm w_param,         Petal::win32lprm l_param    ) noexcept override // 用于我的框架的窗口过程函数的逻辑部分    &#123;        if (message == WM_ERASEBKGND) return 0; // 防止闪烁        return Window::Process(message, w_param, l_param);    &#125;    ... // 其他内容&#125;// 改写为 WIN32 的形式LRESULT CALLBACK MyWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)&#123;    switch (msg)    &#123;    case WM_ERASEBKGND:        return 0;        ... // 其他内容    &#125;    ... // 其他内容&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DX </category>
          
          <category> D2D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DX </tag>
            
            <tag> D2D </tag>
            
            <tag> MSDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++20 比宏更好用的source_location</title>
      <link href="/2024/02/09/The-source-location-Better-Than-Macro/"/>
      <url>/2024/02/09/The-source-location-Better-Than-Macro/</url>
      
        <content type="html"><![CDATA[<h3 id="引"><a href="#引" class="headerlink" title="引"></a>引</h3><pre><code class="C++">// 你不会喜欢这个#if defined(_UNICODE) || defined(UNICODE)#define MY_FILET __FILEW__#else#define MY_FILET __FILE__#endif#define MY_THROW_IF_FAILED(code) \    ::my::ThrowIfFailed(code, TEXT(#code), MY_FILET, __LINE__);</code></pre><a href="#注"><div><i>在过去的日子里，邪恶当道！</i><br /><p align="right"><i>——Kristen Nygaard</i></p></div><div><i>而且，我还持有这样的观点：Cpp必须被摧毁。</i><br />  <p align="right"><i>——老加图（Marcus Porcius Cato）</i></p><br />  </div>  </a><h3 id="曾经当下可用的C"><a href="#曾经当下可用的C" class="headerlink" title="曾经当下可用的C++"></a>曾经当下可用的C++</h3><p>在<text id="dragon">《DX12 3D 游戏开发实战》</text>出版之际(指英文原版，出版日期2016&#x2F;03&#x2F;24，引用自<a href="https://www.amazon.com/Introduction-3D-Game-Programming-DirectX/dp/1942270062">亚马逊</a>)，C++还处于准备迈入C++17的时代。“<a href="#%E5%BC%95">引</a>”中的代码是其中示例的一个变形：API往往返回一个<code>HRESULT</code>类型的值(可以看作是一种错误码)，然后我们可通过<code>FAILED</code>宏来检测返回值是否代表失败。如果失败，还要调用<code>_com_error::ErrorMessgae</code>来获取失败信息，并将文件名、行号、代码和错误信息一并塞到一个自定义异常类的对象里，并抛出它。在程序出错时，这些信息对正在学习D3D的人将很有帮助。  </p><p>“引”中的代码是我根据记忆改写的，可以发现，如果我们无Cpp(C语言预处理器)可用，那么我们将不得不在每次调用<code>my::ThrowIfFailed</code>这个函数时手动填写<code>__FILE__</code>&#x2F;<code>__FILEW__</code>和<code>__LINE__</code>，作为第三和第四个参数，对于大量的检测需求，手工代码代价高昂，耗尽了我们的精力……</p><h4 id="为什么是宏"><a href="#为什么是宏" class="headerlink" title="为什么是宏"></a>为什么是宏</h4><p>宏或者不是一个宏，这是个问题。有什么诡计能让我们同时避免宏和手动填写参数吗？有人可能会想到给函数填写默认参数，但是很遗憾，函数默认参数是行不通的，这种方法不能得到我们想要的效果。最后我们妥协了，选择了宏——如果有其他更好的办法，弗兰克叔叔为什么不告诉我们呢？我记得<a href="https://www.amazon.com/Introduction-3D-Game-Programming-DirectX/dp/1942270062">龙书</a>作者曾在书里阐述过原因，如果你了解宏只是简单的文本替换，你也能马上明白原因所在。预处理能让宏 <code>__FILE__</code>、<code>__LINE__</code> 出现在源文件中正确的位置，此处就不赘述了。  </p><p>此外，<code>TEXT(#code)</code> 这样的东西只适用于MSVC，在 gcc 等平台无法通过编译(如有兴趣可以详细查看预处理器的那些规则)，其中<code>TEXT</code>是宏，可能的实现：  </p><pre><code class="C++">#if defined(_UNICODE) || defined(UNICODE)#define TEXT(quote) L##quote#else#define TEXT(quote) quote#endif</code></pre><p>测试以默认参数的形式实现与ThrowIfFailed相似的代码：  </p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;string&gt;void bad_log(std::string_view msg, const char* caller, const char* file = __FILE__, int line = __LINE__)&#123;    std::cout        &lt;&lt; &quot;FILE: &quot; &lt;&lt; file &lt;&lt; &quot; LINE: &quot; &lt;&lt; line &lt;&lt; &quot; CALLER: &quot; &lt;&lt; caller        &lt;&lt; &quot; MSG: &quot; &lt;&lt; msg &lt;&lt; &quot;\n&quot;;&#125;int main()&#123;    bad_log(&quot;Hell&quot;, __FUNCTION__);    bad_log(&quot;Hell&quot;, __func__);&#125;</code></pre><p>可能的输出：</p><pre><code>FILE: xxx/main.cpp LINE: 5 CALLER: main MSG: HellFILE: xxx/main.cpp LINE: 5 CALLER: main MSG: Hell</code></pre><p>很明显不是我们要的效果，在这个程序中，不管在哪里使用默认参数调用<code>bad_log</code>，它的实参<code>line</code>总是<code>5</code>，由于<code>bad_log</code>调用和<code>bad_log</code>的声明同处一个源文件，它能以我们期望的方式工作，但这不够，如果我们在头文件里对<code>bad_log</code>进行声明(包括默认参数的定义)，它将不能按我们的意愿工作(值总是代表声明它的头文件的名称，使用MSVC测试)。<br>简而言之：Only MACRO can do.  </p><h3 id="当下可用的C"><a href="#当下可用的C" class="headerlink" title="当下可用的C++"></a>当下可用的C++</h3><p>我在写这篇文章的时候，正值除夕(实际写到这里时已经到正月初一了)，可以说各种意义上都进入2024年了。C++23尚且不能被支持完善，但是C++20可用。然而就在C++20中，标准库中增加了<code>std::source_location</code>，以解决我们的燃眉之急：  </p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;source_location&gt;void log(std::string_view msg = &quot;&quot;, const std::source_location&amp; location = std::source_location::current())&#123;    std::cout        &lt;&lt; &quot;FILE: &quot;    &lt;&lt; location.file_name()        &lt;&lt; &quot;(&quot;         &lt;&lt; location.line() &lt;&lt; &quot;,&quot; &lt;&lt; location.column() &lt;&lt; &quot;)&quot;        &lt;&lt; &quot; CALLER: &quot; &lt;&lt; location.function_name()        &lt;&lt; &quot; MSG: &quot;    &lt;&lt; msg &lt;&lt; &quot;\n&quot;;&#125;int main()&#123;    log(&quot;Hello&quot;);&#125;</code></pre><p>可能的输出(MSVC)：</p><pre><code>FILE: xxx/main.cpp(16,2) CALLER: int __cdecl main(void) MSG: Hello</code></pre><p>注：全部使用<code>TAB</code>表示缩进而非空格（这会影响<code>column</code>的返回值，如果使用四个空格表示缩进，我想<code>column</code>的返回值会是<code>5</code>）。  </p><p>这正是我们想要的。</p><h4 id="std-source-location-current"><a href="#std-source-location-current" class="headerlink" title="std::source_location::current"></a>std::source_location::current</h4><p><code>std::source_location::current</code>函数将构造一个表示调用位置的 source_location 对象。  </p><p>若直接调用 <code>current()</code> （通过指名 <code>current()</code> 的函数调用），则它返回对应调用位置的拥有实现定义值的 <code>source_location</code> 对象。该值应当以同预定义宏 <code>__LINE__</code> 与 <code>__FILE__</code> 的方式受 <code>#line</code> 预处理指令影响。<br>若在默认成员初始化器中使用 <code>current()</code>，则返回值对应初始化该数据成员的构造函数定义或聚合初始化的位置。<br>若 <code>current()</code> 用于默认参数，则返回值对应对 <code>current()</code> 的调用的调用点位置。<br>若以任何其他方式调用 <code>current()</code> ，则返回值未指定。  </p><p>注：<code>std::source_location::current</code> 通常要求编译器的内建实现。  </p><p>以上是 <a href="https://zh.cppreference.com/w/cpp/utility/source_location">c++ reference</a> 中的描述(稍有改动)。<br>以下是我写的示例：  </p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;source_location&gt;// curr line: 4void log(std::string_view msg = &quot;&quot;, const std::source_location&amp; location = std::source_location::current())&#123;    std::cout        &lt;&lt; &quot;FILE: &quot; &lt;&lt; location.file_name()        &lt;&lt; &quot;(&quot; &lt;&lt; location.line() &lt;&lt; &quot;,&quot; &lt;&lt; location.column() &lt;&lt; &quot;)&quot;        &lt;&lt; &quot; CALLER: &quot; &lt;&lt; location.function_name()        &lt;&lt; &quot; MSG: &quot; &lt;&lt; msg &lt;&lt; &quot;\n&quot;;&#125;// curr line: 13struct T1 // 使用默认成员初始化器&#123;    std::source_location loc = std::source_location::current();&#125;;// curr line: 18struct T2 // 使用构造函数的成员初始化器列表&#123;    T2() : loc&#123; std::source_location::current() &#125; &#123;&#125;    std::source_location loc;&#125;;// curr line: 24struct T3 // 将在main函数中使用聚合初始化&#123;    std::source_location loc;&#125;;// curr line: 29int main()&#123;    T1 t1&#123;&#125;; // curr line: 32    log(&quot;T1&quot;, t1.loc);    T2 t2&#123;&#125;; // curr line: 34    log(&quot;T2&quot;, t2.loc);    T3 t3&#123; std::source_location::current() &#125;; // curr line: 36    log(&quot;T3&quot;, t3.loc);    return 0;&#125;</code></pre><p>可能的输出(MSVC)：  </p><pre><code>FILE: xxx\main.cpp(32,8) CALLER: int __cdecl main(void) MSG: T1FILE: xxx\main.cpp(21,36) CALLER: __cdecl T2::T2(void) MSG: T2FILE: xxx\main.cpp(36,31) CALLER: int __cdecl main(void) MSG: T3</code></pre><p>预处理指令 <code>#line</code> 影响 <code>std::source_location::current</code> 的例子：  </p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;source_location&gt;void log(std::string_view msg = &quot;&quot;, const std::source_location&amp; location = std::source_location::current())&#123;    std::cout        &lt;&lt; &quot;FILE: &quot; &lt;&lt; location.file_name()        &lt;&lt; &quot;(&quot; &lt;&lt; location.line() &lt;&lt; &quot;,&quot; &lt;&lt; location.column() &lt;&lt; &quot;)&quot;        &lt;&lt; &quot; CALLER: &quot; &lt;&lt; location.function_name()        &lt;&lt; &quot; MSG: &quot; &lt;&lt; msg &lt;&lt; &quot;\n&quot;;&#125;int main()&#123;#line 123456 &quot;foo.cpp&quot;    u8&quot;😁&quot;; // __LINE__: 123456    log(&quot;after #line&quot;, std::source_location::current());  // __LINE__: 123457    return 0;&#125;</code></pre><p>可能的输出(MSVC)：  </p><pre><code>FILE: xxx\foo.cpp(123457,43) CALLER: int __cdecl main(void) MSG: after #line</code></pre><p>预处理指令 <code>#line</code> 的 <a href="https://zh.cppreference.com/w/cpp/preprocessor/line" title="预处理指令 #line">c++ reference</a>。  </p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>在使用C++时，总会听到别人建议“尽量避免使用宏”等。正如题注所隐含的信息，本贾尼就不喜欢C语言预处理器，C++也在竭力提供不依靠预处理器的选择，比如模板使得程序员不必再使用宏来泛型编程、模块使得程序员摆脱<code>#include</code>指令是唯一选择的境地、包括本文所提到的<code>std::source_location</code>也淡化了使用<code>__FILE__</code>和<code>__LINE__</code>的必要性，毕竟，我们现在有新的、更优的方式达到我们的目的。  </p><p>在没有模板的时期编写一个支持泛型的工具 be like：  </p><pre><code class="CC">// stack.hclass ELEM_stack&#123;    ELEM *min, *top, *max;    ...&#125;</code></pre><pre><code class="CC">// main.cpp#define ELEM int#define ELEM_stack int_stack#include &quot;stack.h&quot;#undef ELEM#undef ELEM_stack#define ELEM float#define ELEM_stack float_stack#include &quot;stack.h&quot;#undef ELEM#undef ELEM_stackint_stack is;float_stack fs;</code></pre><blockquote><p>源自《C++语言的设计和演化》(2.9.2 没有模板时的容器类)。</p></blockquote><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><h4 id="引-1"><a href="#引-1" class="headerlink" title="_引"></a>_引</h4><p><em>这<a href="#%E5%BC%95">两句话</a>分别为《C++语言设计与演化》的第一章《C++的史前时代》与最后一章《C语言预处理器》的题记（引用的是中文译本，裘宗燕译。题记中的“Cpp”指“C语言预处理器——C Preprocessor”）。老加图是古罗马政治家，老加图自然不可能对C语言预处理器有什么意见，这句话是模仿的老加图的名言：迦太基必须被摧毁。</em>  </p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
          <category> CPP20 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> CPP20 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享VS2022Preview新UI</title>
      <link href="/2024/02/03/Try-VS2022Preview-New-UI/"/>
      <url>/2024/02/03/Try-VS2022Preview-New-UI/</url>
      
        <content type="html"><![CDATA[<h3 id="标题五个字"><a href="#标题五个字" class="headerlink" title="标题五个字"></a>标题五个字</h3><img src="img.png" alt="效果图" data-align="center"><ul><li>Microsoft Visual Studio Community 2022 (64 位) - Preview</li><li>版本 17.9.0 Preview 5.0</li></ul><p>漂亮得很呐，<del>用上新 ui 立马就觉得老 ui 丑到看不下去了</del>。</p><img src="meme_alice_kawaii.jpg" width="330" height="261" data-align="center">]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C风格字符串与CPP的矛盾</title>
      <link href="/2024/01/16/The-Conflict-Between-C-Style-String-and-CPP/"/>
      <url>/2024/01/16/The-Conflict-Between-C-Style-String-and-CPP/</url>
      
        <content type="html"><![CDATA[<style>.rev {    color: #101595;}</style><h3 id="引"><a href="#引" class="headerlink" title="引"></a>引</h3><img src="blue_pen.jpg" alt="蓝的盆" width="353" height="264" data-align="center"><p>声明：乱写的。  </p><h3 id="陈述"><a href="#陈述" class="headerlink" title="陈述"></a>陈述</h3><ol><li>字符串字面量持有类型 <code>const char_t[N]</code>，字符串长度等于 <code>N-1</code>；  </li><li>字符串字面量保证 null terminated， <code>&quot;...&quot;[N-1]</code> 为 NUL，其中N是(1)中的N；  </li><li>C风格字符串以NUL字符表示字符串结束；  </li><li>字符串字面量通常被用以表示C风格字符串；  </li><li>字符数组对象退化为指针，丢失数组大小信息，容易产生越界访问甚至引起错误；  </li><li>字符串字面量所表示的C风格字符串通常以 <code>const char*</code> 的形式被引用；  </li><li>从类型上无法区分字符串字面量和字符数组(<code>const char[N]</code>)；  </li><li>函数无法区分实参是字符串字面量还是字符数组；  </li><li>C风格API的参数列表 <code>(const char* str, size_t len)</code> 对安全的保证无济于事；  </li><li><code>std::string</code> 不同于C风格字符串，它允许字符串内存在NUL字符；  </li><li><code>std::string</code> 保证 null terminated，保证被当作C风格字符串时符合“以NUL结尾”的规则；  </li><li><code>std::string</code> 提供了 <code>c_str</code> 成员函数；  </li><li>当 <code>std::string</code> 字符串内存在NUL字符时，按C风格字符串的规则，<code>c_str</code> 表示的C风格字符串被字符串内第一个NUL字符“截断”；  </li><li>若 <code>std::string</code> 字符串内存在NUL字符，作为C风格字符串(<code>c_str</code>)时的行为和其本身<a href="#14">不一致</a>； </li><li><code>std::string_view</code> 是字符串视图；  </li><li><code>std::string_view</code> 不同于C风格字符串，它允许字符串内存在NUL字符；  </li><li><code>std::string_view</code> 不保证 null terminated；  </li><li><code>std::string_view</code> 不提供 <code>c_str</code> 成员函数；  </li><li><code>std::string_view</code> 可能是某个字符串的子串；  </li><li><code>std::string_view</code> 不持有所表示的字符串的所有权，而像是一种引用；  </li><li>仅将字符串字面量作为实参用于构造 <code>std::string</code> 和&#x2F;或 <code>std::string_view</code>，将匹配到接受C风格字符串的构造函数；  </li><li>字符串字面量中可以出现值为 NUL 的元素；  </li><li>通过用户自定义字面量的方式使用标准库(命名空间 <code>std::literals::string_literals</code>) 中的 <code>operator&quot;&quot;s</code> 从字符串字面量构造 <code>std::string</code> 对象；  </li><li>通过用户自定义字面量的方式使用标准库(命名空间 <code>std::literals::string_view_literals</code>)中的 <code>operator&quot;&quot;sv</code> 从字符串字面量构造 <code>std::string_view</code> 对象；  </li><li>通过(23)、(24)获得的 <code>std::string</code>、<code>std::string_view</code> 对象，字符串长度应是 <code>N-1</code> (N为字符数组的尺寸)，不管字符串字面量中是否有 NUL，而(20)中的构造方法则会受 NUL 元素的影响，<a href="#25">示例</a>。</li></ol><h3 id="事项和建议"><a href="#事项和建议" class="headerlink" title="事项和建议"></a>事项和建议</h3><ul><li><div class="rev">使用现代C++，</div>  </li><li><div class="rev">尽量使用 string 和 string_view，</div>  </li><li><div class="rev">尽量避免使用字符数组表示字符串，</div>  </li><li><div class="rev">尽量使用用户自定义字面量通过字符串字面量获得string或string_view对象，</div>  </li><li><div class="rev">当函数接收字符串作为输入参数(不修改)时，考虑使用 string_view 做形参的类型：T foo(string_view in);，</div>  </li><li><div class="rev">优先以返回值作为函数输出的方式，</div>  </li><li><div class="rev">当函数接收字符串作为输入输出参数且可能需要修改它的元素时，考虑使用 span&lt;char_t> 做形参的类型(C++20)，</div>  </li><li><div class="rev">当函数接收字符串作为输入输出参数且可能需要修改它时(可能增长或缩短)，考虑使用 string& 做形参的类型，</div>  </li><li><div class="rev">函数向调用方输出字符串应当优先采用返回值的方式返回 string 类型字符串，</div>  </li><li><div class="rev">不要让 string_view 的生命周期长于它引用的字符串的生命周期，如不要返回从局部(自动存储期) string 对象得来的 string_view，对于 span 同理，它们都不拥有资源的所有权，而像是一种“引用”，</div>  </li><li><div class="rev">不要错误使用 `string_view` 和 `span`，如 `string_view result = foo(1); // 函数foo类型为 string(int)`，</div>  </li><li><div class="rev">字符串字面量具有静态存储期。</div></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="14"><a href="#14" class="headerlink" title="14"></a>14</h4><pre><code class="C++">cout &lt;&lt; string&#123; &quot;str\0ing&quot;, 7 &#125; &lt;&lt; &quot;\n&quot;;cout &lt;&lt; string&#123; &quot;str\0ing&quot;, 7 &#125;.c_str() &lt;&lt; &quot;\n&quot;;</code></pre><p>可能的输出：  </p><pre><code>stringstr</code></pre><h4 id="25"><a href="#25" class="headerlink" title="25"></a>25</h4><pre><code class="C++">using namespace std::string_literals;using namespace std::string_view_literals;cout &lt;&lt; string&#123; &quot;str\0ing&quot; &#125; &lt;&lt; &quot;\n&quot;;cout &lt;&lt; string_view&#123; &quot;str\0ing&quot; &#125; &lt;&lt; &quot;\n&quot;;cout &lt;&lt; &quot;str\0ing&quot;s &lt;&lt; &quot;\n&quot;;cout &lt;&lt; &quot;str\0ing&quot;sv &lt;&lt; &quot;\n&quot;;</code></pre><p>可能的输出：  </p><pre><code>strstrstringstring</code></pre>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++20 三路比较运算符的使用</title>
      <link href="/2023/09/22/CPP20-How-to-Use-Three-Way-Comparison/"/>
      <url>/2023/09/22/CPP20-How-to-Use-Three-Way-Comparison/</url>
      
        <content type="html"><![CDATA[<style>    .other_topic {        color: #528252;    }</style><h1 id="C-20三路比较运算符-“”"><a href="#C-20三路比较运算符-“”" class="headerlink" title="C++20三路比较运算符 “&lt;&#x3D;&gt;”"></a>C++20三路比较运算符 “&lt;&#x3D;&gt;”</h1><p>三路比较运算符是 C++20 标准新加入的运算符，本文将介绍三路比较运算符的基本使用和为用户自定义类型提供它的方法。<br>与三路比较运算符相关内容在标头 <code>&lt;compare&gt;</code> 中。</p><h2 id="三路比较运算符的使用"><a href="#三路比较运算符的使用" class="headerlink" title="三路比较运算符的使用"></a>三路比较运算符的使用</h2><h3 id="三路比较运算符的返回值类型"><a href="#三路比较运算符的返回值类型" class="headerlink" title="三路比较运算符的返回值类型"></a>三路比较运算符的返回值类型</h3><p>C++20新增三路比较运算符，用于确定两个值的大小顺序。内置类型的三路比较运算符返回值不为bool类型的纯右值，而是如下类类型之一的一个纯右值。  </p><div id="ordering_types">C++为我们提供的三种相应的类型：</div>  <ul><li><code>std::strong_ordering</code>  </li><li><code>std::partial_ordering</code>  </li><li><code>std::weak_ordering</code></li></ul><p>它们可以被称为“类枚举类型”(使用方法和”C++枚举类-<a href="https://zh.cppreference.com/w/cpp/language/enum" title="cppref">有作用域枚举</a>“有相似之处，但为类类型，故两者是完全不同的东西)。  </p><h3 id="三种ordering的隐式转换"><a href="#三种ordering的隐式转换" class="headerlink" title="三种ordering的隐式转换"></a>三种ordering的隐式转换</h3><p><span id="ordering_cast"> 三种ordering的隐式转换 </span></p><p>其中<code>std::strong_ordering</code>可以隐式转换为<code>std::weak_ordering</code>；<br><code>std::weak_ordering</code>可以隐式转换为<code>std::partial_ordering</code>。</p><h3 id="strong-ordering-强序"><a href="#strong-ordering-强序" class="headerlink" title="strong_ordering 强序"></a>strong_ordering 强序</h3><p>对于整数类型(包括指针类型)和bool类型，三路比较运算的结果是<code>std::strong_ordering</code>类型的，<br>其值为下列值之一：  </p><ul><li><code>std::strong_ordering::less</code> ：指示先序关系，即左操作数小于右操作数  </li><li><code>std::strong_ordering::greater</code> ：指示后序关系，即左操作数大于右操作数  </li><li><code>std::strong_ordering::equivalent</code> ：<text id="intr_equivalent">指示等价关系，即左操作数等于右操作数</text>  </li><li><code>std::strong_ordering::equal</code> (与<a href="#intr_equivalent">equivalent</a>相同)</li></ul><p>注：如果三路比较运算的两操作数一方为bool类型而另一方不是，那么程序非良构。</p><h3 id="partial-ordering-偏序"><a href="#partial-ordering-偏序" class="headerlink" title="partial_ordering 偏序"></a>partial_ordering 偏序</h3><p>对于浮点类型，结果则是<code>std::partial_ordering</code>类型的，<br>其值为下列值之一：  </p><ul><li><code>std::partial_ordering::less</code> ：指示先序关系，即左操作数小于右操作数  </li><li><code>std::partial_ordering::greater</code> ：指示后序关系，即左操作数大于右操作数  </li><li><code>std::partial_ordering::equivalent</code> ：指示等价关系，即左操作数等于右操作数  </li><li><code>std::partial_ordering::unordered</code> ：指示不可比较值的关系，当操作数中存在<code>NaN</code>时结果为<code>unordered</code></li></ul><p>注：正负零的三路比较运算结果为<code>equivalent</code>  </p><h3 id="weak-ordering-弱序"><a href="#weak-ordering-弱序" class="headerlink" title="weak_ordering 弱序"></a>weak_ordering 弱序</h3><p>对于为用户自定义类型提供的三路比较运算符，如果不考虑使用上述两种类型作为返回值类型，则可以考虑<code>std::weak_ordering</code>，<br>其值为下列值之一：  </p><ul><li><code>std::weak_ordering::less</code> ：指示先序关系，即左操作数小于右操作数  </li><li><code>std::weak_ordering::greater</code> ：指示后序关系，即左操作数大于右操作数  </li><li><code>std::weak_ordering::equivalent</code> ：指示等价关系，即左操作数等于右操作数</li></ul><h3 id="更方便地使用ordering"><a href="#更方便地使用ordering" class="headerlink" title="更方便地使用ordering"></a>更方便地使用ordering</h3><p>对于上述提到的类型，C++标准提供了六种和字面量<code>0</code>进行比较的运算符重载，用以确定两个值的大小顺序。设<code>ordering_v</code>为上述三种ordering类型中任意类型的值，则：</p><ol><li><code>ordering_v &lt; 0</code>、<code>0 &gt; ordering_v</code> 为真时 ：对应<code>less</code>  </li><li><code>ordering_v &lt;= 0</code>、<code>0 &gt;= ordering_v</code>为真时 ：对应<code>less</code>∨<code>equivalent</code>  </li><li><code>ordering_v &gt; 0</code>、<code>0 &lt; ordering_v</code> 为真时 ：对应<code>greater</code>  </li><li><code>ordering_v &gt;= 0</code>、<code>0 &lt;= ordering_v</code> 为真时 ：对应<code>greater</code>∨<code>equivalent</code>  </li><li><code>ordering_v == 0</code>、<code>0 == ordering_v</code> 为真时 ：对应<code>equivalent</code>  </li><li><code>ordering_v != 0</code>、<code>0 != ordering_v</code> 为真时 ：对应┐<code>equivalent</code>(非<code>equivalent</code>)</li></ol><h4 id="具名比较函数"><a href="#具名比较函数" class="headerlink" title="具名比较函数"></a>具名比较函数</h4><p>这些函数取三路比较的结果，并转换为六个关系运算符的结果之一。</p><ol><li><code>std::is_eq</code>  </li><li><code>std::is_neq</code>  </li><li><code>std::is_lt</code>  </li><li><code>std::is_lteq</code>  </li><li><code>std::is_gt</code>  </li><li><code>std::is_gteq</code></li></ol><p>设形参名为<code>ordering_v</code>，这些函数将分别返回：</p><ol><li><code>ordering_v == 0</code>  </li><li><code>ordering_v != 0</code>  </li><li><code>ordering_v &lt; 0</code>  </li><li><code>ordering_v &lt;= 0</code>  </li><li><code>ordering_v &gt; 0</code>  </li><li><code>ordering_v &gt;= 0</code></li></ol><p>和 0 进行比较的操作或许有点令人费解(其实还好)，所以我建议尽量使用具名比较函数。  </p><h3 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h3><pre><code class="C++">#include &lt;iostream&gt;// #include &lt;compare&gt; // 相关内容在标头compare中int main()&#123;    using namespace std;    cout &lt;&lt; boolalpha;    auto case_generator = [](auto foo, auto bar)    &#123;        auto print = [](const auto&amp; result)        &#123;            cout                &lt;&lt; &quot; == &quot; &lt;&lt; (result == 0) &lt;&lt; &#39;\n&#39;                &lt;&lt; &quot; != &quot; &lt;&lt; (result != 0) &lt;&lt; &#39;\n&#39;                &lt;&lt; &quot; &lt;  &quot; &lt;&lt; (result &lt;  0) &lt;&lt; &#39;\n&#39;                &lt;&lt; &quot; &lt;= &quot; &lt;&lt; (result &lt;= 0) &lt;&lt; &#39;\n&#39;                &lt;&lt; &quot; &gt;  &quot; &lt;&lt; (result &gt;  0) &lt;&lt; &#39;\n&#39;                &lt;&lt; &quot; &gt;= &quot; &lt;&lt; (result &gt;= 0) &lt;&lt; &#39;\n&#39;;            // 可以使用具名比较函数替换        &#125;;        cout &lt;&lt; &quot;case equivalent\n&quot;;        foo = 100;        bar = 100;        print(foo &lt;=&gt; bar);        cout &lt;&lt; &quot;case less\n&quot;;        foo = 100;        bar = 999;        print(foo &lt;=&gt; bar);        cout &lt;&lt; &quot;case greater\n&quot;;        foo = 999;        bar = 100;        print(foo &lt;=&gt; bar);    &#125;;    cout &lt;&lt; &quot;Integer: \n&quot;;    case_generator(0, 0);    cout &lt;&lt; &quot;Floating point: \n&quot;;    case_generator(0.0, 0.0);    return 0;&#125;</code></pre><p>结果为</p><pre><code>Integer:case equivalent == true != false &lt;  false &lt;= true &gt;  false &gt;= truecase less == false != true &lt;  true &lt;= true &gt;  false &gt;= falsecase greater == false != true &lt;  false &lt;= false &gt;  true &gt;= trueFloating point:case equivalent == true != false &lt;  false &lt;= true &gt;  false &gt;= truecase less == false != true &lt;  true &lt;= true &gt;  false &gt;= falsecase greater == false != true &lt;  false &lt;= false &gt;  true &gt;= true</code></pre><p>对于不同类型间使用三路比较运算符的详细规则，请参阅<a href="https://zh.cppreference.com/w/cpp/language/operator_comparison">cpp-reference</a></p><hr><h2 id="为用户自定义类型提供三路比较运算符"><a href="#为用户自定义类型提供三路比较运算符" class="headerlink" title="为用户自定义类型提供三路比较运算符"></a>为用户自定义类型提供三路比较运算符</h2><p>为用户自定义类型提供三路比较运算符可以将其定义为成员函数和非成员函数两种形式。</p><p>三路比较运算符返回值类型应当为<a href="#ordering_types">三种ordering</a>中任意一个，但是如果要改变为其他类型比如<code>int</code>通常也能通过编译，程序员在编写代码的时候应该清楚自己在做什么。</p><pre><code class="C++">// 重载三路比较运算符示例// 成员函数形式：class CX1&#123;    int val&#123;&#125;;    int insignificant_things&#123;&#125;;public:    auto operator &lt;=&gt; (const CX1&amp; rhs) const    &#123;        return this-&gt;val &lt;=&gt; rhs.val;    &#125;&#125;;// 友元函数形式(推荐)：class CX2&#123;    int val&#123;&#125;;    int insignificant_things&#123;&#125;;public:    friend auto operator &lt;=&gt; (const CX2&amp; lhs, const CX2&amp; rhs)    &#123;        return lhs.val &lt;=&gt; rhs.val;    &#125;&#125;;</code></pre><p>如果提供的是非成员函数而不写成友元函数的形式，则无法使用 <code>=default</code> 定义。  </p><pre><code class="C++">struct A &#123; int a&#123;&#125;; &#125;;std::strong_ordering operator &lt;=&gt; (const A&amp;, const A&amp;) = default; // 错误</code></pre><div class="other_topic"><p>题外话：  </p><p>我更推荐将用户自定义类型的 <code>+</code>, <code>==</code>, <code>&lt;=&gt;</code> 等 rhs 与 lhs 地位平等的运算符以非成员函数的形式在与目标类型<code>T</code>所处的命名空间中(由于<a href="https://zh.cppreference.com/w/cpp/language/adl" title="c++ reference">实参依赖查找(ADL)</a>无需担心名称查找的问题)提供。<br>如果可以，以友元函数形式并且在类中提供定义最好。  </p><pre><code class="C++">namespace mytest&#123;    struct my_t    &#123;        int data&#123;&#125;;        [[nodiscard]] friend constexpr auto operator== (const my_t&amp; lhs, const my_t&amp; rhs) noexcept        &#123;            return lhs.data == rhs.data;        &#125;    &#125;;&#125;auto foo()&#123;    mytest::my_t a&#123; 1 &#125;, b&#123; 2 &#125;;    return a == b; // 可以找到operator==&#125;</code></pre><p>题外话的题外话：<br>对于形参，<code>my_t</code> 的拷贝开销很小，使用引用可能还不如使用拷贝方便高效，但是为了形式上的统一，我此处仍然使用<code>const T&amp;</code>形式。我相信在上述情况下(即给出的代码)，绝大部分情况下编译器最终的优化不会让这种“形式”(即使语义不同)影响程序的性能。<br>如果担心性能问题，请做性能测试(需要考虑是否可以启用编译器优化等条件)。  </p></div><hr><p>为我们的类型提供了三路比较运算符后，<br>若此函数被定义为<code>=default</code>，则C++会自动提供 <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code> 操作。<br>若此函数定义不为<code>=default</code>，则C++会自动提供 <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code> 操作。<br>这是三路比较运算符重载非常有用的一点，如果不需要自动生成的比较操作可以显式弃置，如果自动生成的比较运算符不合自己的期望，也可以自定义它。  </p><p>注：提供<code>&lt;=&gt;</code>运算符的非默认实现(不定义为<code>=default</code>)后，c++ 不会为我们自动生成 <code>==</code>、<code>!=</code> 操作，至于为什么我不知道，有能力可以去翻阅相关提案。<br>为用户自定义类型提供 <code>operator==</code>(返回值类型须为bool) 后，<code>!=</code> 操作可用(C++20 起)。<br><a href="https://zh.cppreference.com/w/cpp/language/default_comparisons" title="预置比较">C++ 参考 预置比较</a><br>C++20 添加了比较运算符的特殊重载解析规则，可以访问<a href="https://sunflavourpetals.github.io/2024/02/22/CPP20%E7%9A%84%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/">我的博客</a>大致了解一下。  </p><p>C++20 起，标准库中提供的基本上都是 <code>operator==</code> 和 <code>operator&lt;=&gt;</code>，而非六个原先的六个比较运算符。  </p><pre><code class="C++">// 示例class CX&#123;    int foo&#123;&#125;;    int bar&#123;&#125;;public:    friend auto operator &lt;=&gt; (const CX&amp;, const CX&amp;) = default;    // 如果我们单不希望此类有 &quot;&gt;=&quot; 比较运算符，则显示弃置它：    bool operator &gt;= (const CX&amp;) const = delete; // 弃置 &gt;= 运算符    // 如果我们单希望 &quot;&gt;&quot; 运算符的比较方式是成员属性之和相比较，而不是根据默认的三路比较运算符的比较方式，则自定义它：    bool operator &gt; (const CX&amp; rhs) const noexcept    &#123;        return (this-&gt;foo + this-&gt;bar) &gt; (rhs.foo + rhs.bar);    &#125;&#125;;</code></pre><h3 id="默认的三路比较运算符"><a href="#默认的三路比较运算符" class="headerlink" title="默认的三路比较运算符"></a>默认的三路比较运算符</h3><p>当我们要为一个自定义类型提供三路比较运算符时，有时可以考虑采用默认的三路比较运算符。<br>默认的三路比较运算符返回值根据<a href="#ordering_cast">三种ordering的隐式转换规则</a>采取相应的类型。<br>即：有<code>std::partial_ordering</code>时为<code>std::partial_ordering</code>，否则有<code>std::weak_ordering</code>时为<code>std::weak_ordering</code>，否则为<code>std::strong_ordering</code>。<br>如果想要使用默认的三路比较运算符，类的成员必须全部满足：<strong>类型为基本类型</strong>或<strong>具有重载的返回值为<a href="#ordering_types">上述三种ordering</a>的三路比较运算符</strong>的类型，基类(如果有)须<strong>具有重载的返回值为<a href="#ordering_types">上述三种ordering</a>的三路比较运算符</strong>，否则该 <code>operator&lt;=&gt;</code> 将被定义为弃置。  </p><p>示例：</p><pre><code class="C++">// 成员函数形式：class CX1&#123;    int foo&#123;&#125;;    int bar&#123;&#125;; // memberspublic:    auto operator &lt;=&gt; (const CX1&amp;) const = default; // 返回类型为 strong_ordering&#125;;// 友元函数形式：class CX2&#123;    int foo&#123;&#125;;    double bar&#123;&#125;; // memberspublic:    friend auto operator &lt;=&gt; (const CX2&amp;, const CX2&amp;) = default; // 返回类型为 partial_ordering&#125;;class CX3&#123;    CX1 cx1&#123;&#125;;    CX2 cx2&#123;&#125;;public:    auto operator &lt;=&gt; (const CX3&amp;) const = default; // 返回类型为 partial_ordering&#125;;class CX4 &#123;&#125;;class CX5 : public CX4&#123;public:    friend auto operator &lt;=&gt; (const CX5&amp;, const CX5&amp;) = default; // 弃置&#125;class CX6&#123;    CX4 cx4&#123;&#125;;public:    friend auto operator &lt;=&gt; (const CX6&amp;, const CX6&amp;) = default; // 弃置&#125;</code></pre><p>默认生成的三路比较运算符返回值取决于此：<br>通过依次以计算 &lt;&#x3D;&gt; 比较基类(从左到右，深度优先)，然后比较非静态成员(按声明顺序)子对象，递归地展开数组成员(按下标递增)，并在发现不相等的结果时提前停止的方式执行字典序比较，即直到结果出现第一个 <code>less</code>、<code>greater</code>、<code>unordered</code> 或全部比较完成，将得到的最后一个结果作为整个三路比较运算的结果，如果未出现非 <code>equivalent</code> 的结果则返回 <code>equivalent</code>。  </p><p>示例：</p><pre><code class="C++">#include &lt;iostream&gt;struct TestBase&#123;    int base1&#123;&#125;;    int base2[3]&#123;&#125;;    friend auto operator&lt;=&gt;(const TestBase&amp; lhs, const TestBase&amp; rhs) = default;&#125;;struct Test : TestBase&#123;    int m1&#123;&#125;; double m2&#123;&#125;; bool m3&#123;&#125;;    friend auto operator&lt;=&gt;(const Test&amp; lhs, const Test&amp; rhs) = default;&#125;;int main()&#123;    Test t1&#123; 0, &#123; 1, 2, 3 &#125;, 1, 2.0, true &#125;;    Test t2&#123; 0, &#123; 1, 2, 3 &#125;, 1, 3.0, false &#125;;    // 基类第一个成员 base1 比较结果为 equivalent, 继续    // 基类第二个成员 base2 索引为 0 的元素比较结果为 equivalent, 继续    // 基类第二个成员 base2 索引为 1 的元素比较结果为 equivalent, 继续    // 基类第二个成员 base2 索引为 2 的元素比较结果为 equivalent, 继续    // 第一个成员属性 m1 比较结果为 equivalent, 继续    // 第二个成员属性 m2 比较结果为 less, 得到结果，不再比较第三个成员属性 m3 了    if ((t1 &lt;=&gt; t2) &lt; 0) &#123; std::cout &lt;&lt; &quot;t1 &lt; t2&quot;; &#125;    return 0;&#125;</code></pre><p>结果为</p><pre><code class="output">t1 &lt; t2</code></pre><hr><p><a href="https://zh.cppreference.com/w/cpp/language/operator_comparison" title="zh cppreference operator_comparison">C++参考 | 比较运算符</a><br><a href="https://zh.cppreference.com/w/cpp/header/compare" title="zh cppreference compare">C++参考 | 标头 compare</a>  </p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
          <category> CPP20 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> CPP20 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 使用extern关键字声明全局常量的作用</title>
      <link href="/2023/09/18/The-Effect-of-Using-extern-in-const-variable-Declaration/"/>
      <url>/2023/09/18/The-Effect-of-Using-extern-in-const-variable-Declaration/</url>
      
        <content type="html"><![CDATA[<p><a href="#toolongtowatch">太长不看环节</a></p><h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>通常在编写大型C&#x2F;C++程序时，我们会用到分文件编写程序的方式组织代码，按照不同的功能模块(此模块非c++20模块)，将一份程序分成不同的部分。</p><p>为了让模块之间能够相互访问，需要将声明放在头文件(.h)中，将定义放在源文件(.c&#x2F;.cpp)中。</p><pre><code class="cpp">// header &quot;foo.h&quot;int foo();</code></pre><pre><code class="cpp">// source &quot;foo.cpp&quot;#include &quot;foo.h&quot;int foo()&#123;    return &#123;&#125;;&#125;</code></pre><p>这样，其他模块只要使用了预处理指令<code>#include &quot;foo.h&quot;</code>，就能使用函数<code>foo</code>了(<del>每个用到<code>foo</code>的源文件中，直接在使用之前声明一次也行</del>)。</p><pre><code class="cpp">// main.cpp#include &quot;foo.h&quot;int main()&#123;    return foo();&#125;</code></pre><hr><p>预处理指令<code>#include &quot;foo.h&quot;</code>的作用仅仅只是在预处理阶段使用”foo.h”文件的内容替换掉这条指令而已。</p><p>也就是说，编译器在编译”main.cpp”阶段，代码中只有孤零零一条声明：<code>int foo();</code>，而没有函数<code>foo</code>的定义，大家都不知道这个函数<code>foo</code>在哪里，也不知道这个函数<code>foo</code>干了什么，只知道有个叫<code>foo</code>的函数并且这里调用了函数<code>foo</code>。</p><p>虽然有些疑问，但是”main.cpp”还是被成功编译了，生成了一个”main.obj”(Windows平台)，<code>.obj</code>文件即”可重定位目标文件”，里面装满了编译器生成的目标代码。这时，”foo.cpp”也被编译了，生成了一个”foo.obj”文件……</p><p>现在来到了链接阶段，”main.cpp”中的<code>main</code>函数调用了<code>foo</code>函数，现在我们知道<code>foo</code>函数在”foo.obj”中，链接程序将它和<code>main</code>函数一并放入了”main.exe”(假设是这个名字)，并且在<code>main</code>函数中调用<code>foo</code>函数的地方填上了<code>foo</code>函数的位置。</p><p>这样，<code>main</code>函数就知道<code>foo</code>函数在哪了，当程序执行到此处时，<code>main</code>函数将把控制权交给<code>foo</code>，等着它将返回值交给<code>main</code>……</p><p>这就是小学生都知道的C&#x2F;C++语言从源码到可执行文件的流程。<del>当然，如果你照着上面写了然后还编译链接了，甚至还反编译了，甚至还一条条去看汇编指令了，最后发现<code>main</code>函数直接返回了0，说程序编译链接都是骗人的……别急，这可能是编译器将<code>foo</code>函数直接内联了，用代码替换了函数调用，这不是我们要讨论的内容。</del></p><p>一个内联的例子，用<code>mov eax, 5</code>替换了对函数foo的调用(Release模式下)。</p><img title="例子" src="inline_o.png" data-align="center"><h2 id="Extern-在声明全局变量时的作用"><a href="#Extern-在声明全局变量时的作用" class="headerlink" title="Extern 在声明全局变量时的作用"></a>Extern 在声明全局变量时的作用</h2><p>闹了半天主角”extern”都没出现，现在开始进入正题。</p><p>对函数进行分文件编写是呼吸一样平常的事情，而经常编写C&#x2F;C++程序的话，全局变量&#x2F;命名空间局部变量将是一个绕不开的东西。它也能像函数一样，将声明与定义分离。下面将进行展示~  </p><p>(使用MSVC)</p><pre><code class="cpp">// header &quot;bar.h&quot;extern int bar;</code></pre><pre><code class="cpp">// source &quot;bar.cpp&quot;int bar&#123; 123 &#125;;</code></pre><pre><code class="cpp">// main.cpp#include &quot;bar.h&quot;int main()&#123;    return bar;&#125;</code></pre><p>没错， <code>extern</code>关键字出现了，它告诉链接器这个叫<code>bar</code>的，等会去别的翻译单元中查找定义。通常情况下，非常量全局变量具有外部链接，如你所见，这个<code>bar</code>就是一个非常量全局变量，它具有外部链接，链接器让远在他<code>.obj</code>的<code>main</code>函数也能找到它。</p><hr><div id="toolongtowatch">我所熟知的情况到这就结束了，但是前几天，我在整理旧的代码的时候，发现了一个奇怪又熟悉的东西：</div><pre><code class="cpp">namespace Petal::UserEntrance&#123;    extern const fptr&lt;int&gt; pt_user_main&#123; &amp;::MainFunc &#125;;    extern const ptrc&lt;TChar&gt; pt_user_main_name&#123; Petal_TStr(#MainFunc) &#125;;&#125;</code></pre><p>在定义的时候出现了关键字<code>extern</code>，显然此时我已经忘记了<code>extern</code>在此处的作用，我抱着好奇的心态将它删了(指<code>extern</code>)，结果出现了链接错误：</p><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://learn.microsoft.com/zh-cn/cpp/error-messages/tool-errors/linker-tools-error-lnk2001">LNK2001</a></td><td>无法解析的外部符号 “int (__cdecl* Petal::UserEntrance::pt_user_main)(void)” (?pt_user_main@UserEntrance@Petal@@3Q6AHXZEA)</td></tr><tr><td><a href="https://learn.microsoft.com/zh-cn/cpp/error-messages/tool-errors/linker-tools-error-lnk2001">LNK2001</a></td><td>无法解析的外部符号 “wchar_t const * const Petal::UserEntrance::pt_user_main_name” (?pt_user_main_name@UserEntrance@Petal@@3QEB_WEB)</td></tr><tr><td><a href="https://learn.microsoft.com/zh-cn/cpp/error-messages/tool-errors/linker-tools-error-lnk1120">LNK1120</a></td><td>2 个无法解析的外部命令</td></tr></tbody></table><p>经典链接错误  </p><p><em>Classic</em>  </p><p>我忘记了当时为什么会这样写，查下MSDN。</p><p><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/extern-cpp?view=msvc-170">extern (C++) | Microsoft Learn | zh-cn</a></p><p><a href="https://learn.microsoft.com/en-us/cpp/cpp/extern-cpp?view=msvc-170">extern (C++) | Microsoft Learn | en-us</a></p><p>我果然是健忘的，故写下博客以便未来哪天犯傻了能快速找到之前的经验</p><img title="cat" src="my_cat.jpg" width="298" data-align="center"><p>也就是说，全局常量变量具有内部链接，即使在外声明也无法使用，除非在定义时在前面加上关键字<code>extern</code>。用<code>bar</code>来举例如下：</p><pre><code class="cpp">// header &quot;bar.h&quot;extern const int bar;</code></pre><pre><code class="cpp">// source &quot;bar.cpp&quot;extern const int bar&#123; 123 &#125;;</code></pre><pre><code class="cpp">// main.cpp#include &quot;bar.h&quot;int main()&#123;    return bar;&#125;</code></pre><hr><h2 id="C-全局变量的链接"><a href="#C-全局变量的链接" class="headerlink" title="C++全局变量的链接"></a>C++全局变量的链接</h2><p>既然都说到这份上，还是复习一下VC++中全局变量(及命名空间局部变量)所具有的链接(不包含C++20及更高标准的内容)。</p><p>仅内部链接：</p><ul><li><p>使用 <code>static</code> 声明的全局变量或命名空间局部变量</p></li><li><p>类型具有 <code>const</code> 限定且无 <code>inline</code> 说明符 并且 先前没有外部链接的声明 的全局变量或命名空间局部变量</p></li><li><p>无名命名空间及其中的命名空间中的命名空间局部变量</p></li></ul><p>例</p><pre><code class="cpp">// test.cppstatic int foo&#123; 1 &#125;;const int bar&#123; 2 &#125;;namespace &#123; int unnamed&#123; 3 &#125;; &#125;</code></pre><pre><code class="cpp">// main.cppextern int foo;extern const int bar;extern int baz;int main()&#123;    int&#123; foo &#125;; // LNK2001    int&#123; bar &#125;; // LNK2001    int&#123; baz &#125;; // LNK2001    return 0;&#125;</code></pre><p>外部链接(不在无名命名空间及其中的命名空间内定义的情况)：</p><ul><li><p>使用extern声明的全局变量或命名空间局部变量</p></li><li><p>没有const限定的全局变量或命名空间局部变量</p></li></ul><p>例</p><pre><code class="cpp">// test.cppextern const int foo&#123; 1 &#125;;int bar&#123; 2 &#125;;extern const int baz;const int baz&#123; 3 &#125;;</code></pre><pre><code class="cpp">// main.cppextern const int foo;extern int bar;extern const int baz;int main()&#123;    int&#123; foo &#125;;    int&#123; bar &#125;;    int&#123; baz &#125;;    return 0;&#125;</code></pre><p>值得注意的是，C++引用忽略限定符，所以如下也能通过编译链接(MSVC)：</p><pre><code class="cpp">// test.cppint val&#123; 100 &#125;;int const/*此const限定int*/ &amp;const/*此const无效*/ test&#123; val &#125;;</code></pre><pre><code class="cpp">extern const int&amp; const test;int main()&#123;    int&#123; test &#125;;    return 0;&#125;</code></pre><p>但请不要这么编写代码。</p><p>更复杂的例子(其实分清顶层const和底层const的区别就不会被const限定迷惑住了)</p><pre><code class="cpp">// test.cppint* ptr1&#123; nullptr &#125;; // 外部链接const int* ptrc1&#123; nullptr &#125;; // 外部链接int *const cptr1&#123; nullptr &#125;; // 内部链接int const* const cptrc1&#123; nullptr &#125;; // 内部链接int const* const&amp; cptrcr1&#123; cptrc1 &#125;; // 外部链接extern int const* const cptrc2&#123; nullptr &#125;; // 外部链接</code></pre><p>C++参考</p><p><a href="https://zh.cppreference.com/w/cpp/language/storage_duration">存储类说明符 - cppreference.com</a></p><p><a href="https://en.cppreference.com/w/cpp/language/storage_duration">Storage class specifiers - cppreference.com</a></p><hr><p>完结！</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 猝不及防系列 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
