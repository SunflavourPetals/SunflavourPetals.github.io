<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>比宏更好用的source_location</title>
      <link href="/2024/02/09/%E6%AF%94%E5%AE%8F%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84source-location/"/>
      <url>/2024/02/09/%E6%AF%94%E5%AE%8F%E6%9B%B4%E5%A5%BD%E7%94%A8%E7%9A%84source-location/</url>
      
        <content type="html"><![CDATA[<h3 id="引"><a href="#引" class="headerlink" title="引"></a>引</h3><pre><code class="C++">// 你不会喜欢这个#if defined(_UNICODE) || defined(UNICODE)#define MY_FILET __FILEW__#else#define MY_FILET __FILE__#endif#define MY_THROW_IF_FAILED(code) \    ::my::ThrowIfFailed(code, TEXT(#code), MY_FILET, __LINE__);</code></pre><a href="#注"><div><i>在过去的日子里，邪恶当道！</i><br /><p align="right"><i>——Kristen Nygaard</i></p></div><div><i>而且，我还持有这样的观点：Cpp必须被摧毁。</i><br />  <p align="right"><i>——老加图（Marcus Porcius Cato）</i></p><br />  </div>  </a><h3 id="曾经当下可用的C"><a href="#曾经当下可用的C" class="headerlink" title="曾经当下可用的C++"></a>曾经当下可用的C++</h3><p>在<text id="dragon">《DX12 3D 游戏开发实战》</text>出版之际(指英文原版，出版日期2016&#x2F;03&#x2F;24，引用自<a href="https://www.amazon.com/Introduction-3D-Game-Programming-DirectX/dp/1942270062">亚马逊</a>)，C++还处于准备迈入C++17的时代。“<a href="#%E5%BC%95">引</a>”中的代码是其中示例的一个变形：API往往返回一个<code>HRESULT</code>类型的值(可以看作是一种错误码)，然后我们可通过<code>FAILED</code>宏来检测返回值是否代表失败。如果失败，还要调用<code>_com_error::ErrorMessgae</code>来获取失败信息，并将文件名、行号、代码和错误信息一并塞到一个自定义异常类的对象里，并抛出它。在程序出错时，这些信息对正在学习D3D的人将很有帮助。  </p><p>“引”中的代码是我根据记忆改写的，可以发现，如果我们无Cpp(C语言预处理器)可用，那么我们将不得不在每次调用<code>my::ThrowIfFailed</code>这个函数时手动填写<code>__FILE__</code>&#x2F;<code>__FILEW__</code>和<code>__LINE__</code>，作为第三和第四个参数，对于大量的检测需求，手工代码代价高昂，耗尽了我们的精力……</p><h4 id="为什么是宏"><a href="#为什么是宏" class="headerlink" title="为什么是宏"></a>为什么是宏</h4><p>宏或者不是一个宏，这是个问题。有什么诡计能让我们同时避免宏和手动填写参数吗？有人可能会想到给函数填写默认参数，但是很遗憾，函数默认参数是行不通的，这种方法不能得到我们想要的效果。最后我们妥协了，选择了宏——如果有其他更好的办法，弗兰克叔叔为什么不告诉我们呢？我记得<a href="https://www.amazon.com/Introduction-3D-Game-Programming-DirectX/dp/1942270062">龙书</a>作者曾在书里阐述过原因，如果你了解宏只是简单的文本替换，你也能马上明白原因所在。预处理能让宏 <code>__FILE__</code>、<code>__LINE__</code> 出现在源文件中正确的位置，此处就不赘述了。  </p><p>此外，<code>TEXT(#code)</code> 这样的东西只适用于MSVC，在 gcc 等平台无法通过编译(如有兴趣可以详细查看预处理器的那些规则)，其中<code>TEXT</code>是宏，可能的实现：  </p><pre><code class="C++">#if defined(_UNICODE) || defined(UNICODE)#define TEXT(quote) L##quote#else#define TEXT(quote) quote#endif</code></pre><p>测试以默认参数的形式实现与ThrowIfFailed相似的代码：  </p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;string&gt;void bad_log(std::string_view msg, const char* caller, const char* file = __FILE__, int line = __LINE__)&#123;    std::cout        &lt;&lt; &quot;FILE: &quot; &lt;&lt; file &lt;&lt; &quot; LINE: &quot; &lt;&lt; line &lt;&lt; &quot; CALLER: &quot; &lt;&lt; caller        &lt;&lt; &quot; MSG: &quot; &lt;&lt; msg &lt;&lt; &quot;\n&quot;;&#125;int main()&#123;    bad_log(&quot;Hell&quot;, __FUNCTION__);    bad_log(&quot;Hell&quot;, __func__);&#125;</code></pre><p>可能的输出：</p><pre><code>FILE: xxx/main.cpp LINE: 5 CALLER: main MSG: HellFILE: xxx/main.cpp LINE: 5 CALLER: main MSG: Hell</code></pre><p>很明显不是我们要的效果，在这个程序中，不管在哪里使用默认参数调用<code>bad_log</code>，它的实参<code>line</code>总是<code>5</code>，由于<code>bad_log</code>调用和<code>bad_log</code>的声明同处一个源文件(就算使用头文件，它们也是同处一个翻译单元，但是<code>__LINE__</code>会被头文件包含顺序影响)，它能以我们期望的方式工作，但这不够。简而言之：Only MACRO can do.  </p><h3 id="当下可用的C"><a href="#当下可用的C" class="headerlink" title="当下可用的C++"></a>当下可用的C++</h3><p>我在写这篇文章的时候，正值除夕(实际写到这里时已经到正月初一了)，可以说各种意义上都进入2024年了。C++23尚且不能被支持完善，但是C++20可用。然而就在C++20中，标准库中增加了<code>std::source_location</code>，以解决我们的燃眉之急：  </p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;source_location&gt;void log(std::string_view msg = &quot;&quot;, const std::source_location&amp; location = std::source_location::current())&#123;    std::cout        &lt;&lt; &quot;FILE: &quot;    &lt;&lt; location.file_name()        &lt;&lt; &quot;(&quot;         &lt;&lt; location.line() &lt;&lt; &quot;,&quot; &lt;&lt; location.column() &lt;&lt; &quot;)&quot;        &lt;&lt; &quot; CALLER: &quot; &lt;&lt; location.function_name()        &lt;&lt; &quot; MSG: &quot;    &lt;&lt; msg &lt;&lt; &quot;\n&quot;;&#125;int main()&#123;    log(&quot;Hello&quot;);&#125;</code></pre><p>可能的输出(MSVC)：</p><pre><code>FILE: xxx/main.cpp(16,2) CALLER: int __cdecl main(void) MSG: Hello</code></pre><p>注：全部使用<code>TAB</code>表示缩进而非空格（这会影响<code>column</code>的返回值，如果使用四个空格表示缩进，我想<code>column</code>的返回值会是<code>5</code>）。  </p><p>这正是我们想要的。</p><h4 id="std-source-location-current"><a href="#std-source-location-current" class="headerlink" title="std::source_location::current"></a>std::source_location::current</h4><p><code>std::source_location::current</code>函数将构造一个表示调用位置的 source_location 对象。  </p><p>若直接调用 <code>current()</code> （通过指名 <code>current()</code> 的函数调用），则它返回对应调用位置的拥有实现定义值的 <code>source_location</code> 对象。该值应当以同预定义宏 <code>__LINE__</code> 与 <code>__FILE__</code> 的方式受 <code>#line</code> 预处理指令影响。<br>若在默认成员初始化器中使用 <code>current()</code>，则返回值对应初始化该数据成员的构造函数定义或聚合初始化的位置。<br>若 <code>current()</code> 用于默认参数，则返回值对应对 <code>current()</code> 的调用的调用点位置。<br>若以任何其他方式调用 <code>current()</code> ，则返回值未指定。  </p><p>注：<code>std::source_location::current</code> 通常要求编译器的内建实现。  </p><p>以上是 <a href="https://zh.cppreference.com/w/cpp/utility/source_location">c++ reference</a> 中的描述(稍有改动)。<br>以下是我写的示例：  </p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;source_location&gt;// curr line: 4void log(std::string_view msg = &quot;&quot;, const std::source_location&amp; location = std::source_location::current())&#123;    std::cout        &lt;&lt; &quot;FILE: &quot; &lt;&lt; location.file_name()        &lt;&lt; &quot;(&quot; &lt;&lt; location.line() &lt;&lt; &quot;,&quot; &lt;&lt; location.column() &lt;&lt; &quot;)&quot;        &lt;&lt; &quot; CALLER: &quot; &lt;&lt; location.function_name()        &lt;&lt; &quot; MSG: &quot; &lt;&lt; msg &lt;&lt; &quot;\n&quot;;&#125;// curr line: 13struct T1 // 使用默认成员初始化器&#123;    std::source_location loc = std::source_location::current();&#125;;// curr line: 18struct T2 // 使用构造函数的成员初始化器列表&#123;    T2() : loc&#123; std::source_location::current() &#125; &#123;&#125;    std::source_location loc;&#125;;// curr line: 24struct T3 // 将在main函数中使用聚合初始化&#123;    std::source_location loc;&#125;;// curr line: 29int main()&#123;    T1 t1&#123;&#125;; // curr line: 32    log(&quot;T1&quot;, t1.loc);    T2 t2&#123;&#125;; // curr line: 34    log(&quot;T2&quot;, t2.loc);    T3 t3&#123; std::source_location::current() &#125;; // curr line: 36    log(&quot;T3&quot;, t3.loc);    return 0;&#125;</code></pre><p>可能的输出(MSVC)：  </p><pre><code>FILE: xxx\main.cpp(32,8) CALLER: int __cdecl main(void) MSG: T1FILE: xxx\main.cpp(21,36) CALLER: __cdecl T2::T2(void) MSG: T2FILE: xxx\main.cpp(36,31) CALLER: int __cdecl main(void) MSG: T3</code></pre><p>预处理指令 <code>#line</code> 影响 <code>std::source_location::current</code> 的例子：  </p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;source_location&gt;void log(std::string_view msg = &quot;&quot;, const std::source_location&amp; location = std::source_location::current())&#123;    std::cout        &lt;&lt; &quot;FILE: &quot; &lt;&lt; location.file_name()        &lt;&lt; &quot;(&quot; &lt;&lt; location.line() &lt;&lt; &quot;,&quot; &lt;&lt; location.column() &lt;&lt; &quot;)&quot;        &lt;&lt; &quot; CALLER: &quot; &lt;&lt; location.function_name()        &lt;&lt; &quot; MSG: &quot; &lt;&lt; msg &lt;&lt; &quot;\n&quot;;&#125;int main()&#123;#line 123456 &quot;foo.cpp&quot;    u8&quot;😁&quot;; // __LINE__: 123456    log(&quot;after #line&quot;, std::source_location::current());  // __LINE__: 123457    return 0;&#125;</code></pre><p>可能的输出(MSVC)：  </p><pre><code>FILE: xxx\foo.cpp(123457,43) CALLER: int __cdecl main(void) MSG: after #line</code></pre><p>预处理指令 <code>#line</code> 的 <a href="https://zh.cppreference.com/w/cpp/preprocessor/line" title="预处理指令 #line">c++ reference</a>。  </p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>在使用C++时，总会听到别人建议“尽量避免使用宏”等。正如题注所隐含的信息，本贾尼就不喜欢C语言预处理器，C++也在竭力提供不依靠预处理器的选择，比如模板使得程序员不必再使用宏来泛型编程、模块使得程序员摆脱<code>#include</code>指令是唯一选择的境地、包括本文所提到的<code>std::source_location</code>也淡化了使用<code>__FILE__</code>和<code>__LINE__</code>的必要性，毕竟，我们现在有新的、更优的方式达到我们的目的。  </p><p>在没有模板的时期编写一个支持泛型的工具 be like：  </p><pre><code class="CC">// stack.hclass ELEM_stack&#123;    ELEM *min, *top, *max;    ...&#125;</code></pre><pre><code class="CC">// main.cpp#define ELEM int#define ELEM_stack int_stack#include &quot;stack.h&quot;#undef ELEM#undef ELEM_stack#define ELEM float#define ELEM_stack float_stack#include &quot;stack.h&quot;#undef ELEM#undef ELEM_stackint_stack is;float_stack fs;</code></pre><blockquote><p>源自《C++语言的设计和演化》(2.9.2 没有模板时的容器类)。</p></blockquote><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><h4 id="引-1"><a href="#引-1" class="headerlink" title="_引"></a>_引</h4><p><em>这两句话分别为《C++语言设计与演化》的第一章《C++的史前时代》与最后一章《C语言预处理器》的题记（引用的是中文译本，裘宗燕译。题记中的“Cpp”指“C语言预处理器——C Preprocessor”）。老加图是古罗马政治家，老加图自然不可能对C语言预处理器有什么意见，这句话是模仿的老加图的名言：迦太基必须被摧毁。</em>  </p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
          <category> CPP20 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> CPP20 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享VS2022Preview新UI</title>
      <link href="/2024/02/03/%E5%88%86%E4%BA%ABVS2022Preview%E6%96%B0UI/"/>
      <url>/2024/02/03/%E5%88%86%E4%BA%ABVS2022Preview%E6%96%B0UI/</url>
      
        <content type="html"><![CDATA[<h3 id="标题五个字"><a href="#标题五个字" class="headerlink" title="标题五个字"></a>标题五个字</h3><img src="img_01.png" alt="效果图1" data-align="center"><img src="img_02.png" alt="效果图2" data-align="center"><img src="img_03.png" alt="效果图3" data-align="center"><ul><li>Microsoft Visual Studio Community 2022 (64 位) - Preview</li><li>版本 17.9.0 Preview 5.0</li></ul><p>漂亮得很呐，<del>用上新 ui 立马就觉得老 ui 丑到看不下去了</del>。</p><img src="meme_alice_kawaii.jpg" alt="meme_alice_可爱！" width="330" height="261" data-align="center">]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C风格字符串与CPP的矛盾</title>
      <link href="/2024/01/16/C%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8ECPP%E7%9A%84%E7%9F%9B%E7%9B%BE/"/>
      <url>/2024/01/16/C%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8ECPP%E7%9A%84%E7%9F%9B%E7%9B%BE/</url>
      
        <content type="html"><![CDATA[<style>.big_thing {    color: #d01010;}.striking_thing {    color: #ef9010;}.green_text {    color: #20c010;}.rev {    color: #1537f5;}</style><h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><img src="blue_pen.jpg" alt="蓝的盆" width="353" height="264" data-align="center"><p>声明：这文章是乱写的，就是为了喷而已，弄得一团乱麻不明所以，可以看个乐。<br>主要缘由是为我的框架实现 <code>Debug::print</code> 时产生了一些思考。  </p><h2 id="定义字符串"><a href="#定义字符串" class="headerlink" title="定义字符串"></a>定义字符串</h2><p>读之前先想想: 什么是字符串?(为了简单起见，只展示和<code>char</code>类型有关的内容)</p><ul><li>字符串字面量是字符串吗? <code>&quot;literal&quot;</code> <code>R&quot;(literal)&quot;</code> …</li><li>字符数组是字符串吗? <code>const char str[N]</code> <code>char str[N]</code></li><li>指向字符类型数据的指针是字符串吗? <code>const char *str</code> <code>char *str</code></li><li><code>std::string</code> 类型的对象是字符串吗?</li><li><code>std::string_view</code> 类型的对象是字符串吗?</li></ul><p>这个世界太乱  </p><p><a href="#%E6%80%BB%E7%BB%93">太长不看环节</a></p><h3 id="从C里来"><a href="#从C里来" class="headerlink" title="从C里来"></a>从C里来</h3><p>以NUL结尾是C风格字符串的特征。<br>C++字符串字面量类型为 <code>const char_t[N]</code>，C和C++都在语言层面做出了字符串字面量以NUL(即<code>\0</code>)结尾的保证，例如 C++ 中，<code>&quot;str&quot;</code> 类型为 <code>const char[4]</code>，值为 <code>&#123; s, t, r, NUL &#125;</code></p><p>首先认为字符串字面量是字符串。  </p><p><code>std::cout &lt;&lt; &quot;Hello world&quot;;</code> 这样的代码很符合直觉。</p><p><text class="striking_thing"><b>字符串字面量有类型 <code>const char_t[N]</code></b></text>。  </p><hr><p>既然字符串字面量有类型 <code>const char_t[N]</code>。<br>那么字符数组是字符串吗？  </p><div>首先解释一下我为什么要这样问。<br />  <b><i>为什么考虑字符数组是否为字符串？</i></b><br />  我的答案是因为字符串字面量持有字符数组类型，在作为函数的实参时字符串字面量和字符数组(持有“const char_t[N]”类型)在被调用者看来是一样的，字符串字面量在他眼里并不特别，即“被调用者无法区分实参是字符串字面量还是字符数组”。这就引出了下一个疑惑。<br />  <b><i>为什么纠结字符串字面量和字符数组的区别？/为什么要区分它们？</i></b><br />  我的答案是，字符数组无法被保证具有C风格字符串以NUL结尾的规则，尤其是在退化为指针的情况下，使用它则有安全隐患。而字符串字面量遵守这一规则，具有更强的约束。字符串字面量是字符数组的一个特例，它在字符数组的类型之上还有 字符串+字符NUL 的含义。<br />即字符串字面量保证字符串内容后紧邻的值能被解释为字符NUL且字符串字面量所保证的NUL字符不是字符串内容的一部分。<br /><br />  这两个不同的事物都持有类型“const char_t[N]”，造成了混乱，这就是我喷的点。<br /></div><br /><hr><p>如果只考虑C风格字符串，那么它是不是字符串需要依靠是否以NUL结尾这一规则来判断。如果将其视为字符串，那我们程序员必须保证我们创造的字符数组始终符合以上规则，即字符数组范围内始终存在至少一个 <code>NUL</code> 字符，否则我们不能将字符数组和C风格字符串这一概念绑定<br>考虑：  </p><ul><li><code>char cstr[] = &quot;str&quot;</code> &#x2F;&#x2F; 暂时可以当成C风格字符串使用(范围cstr内存在NUL时)  </li><li><code>char arr[] = &#123; &#39;s&#39;, &#39;t&#39;, &#39;r&#39; &#125;</code> &#x2F;&#x2F; 不能当成C风格字符串！</li></ul><p>故：<br>字符数组不总是C风格字符串<code>-&gt;</code>不能仅通过对象持有字符数组类型就判定其为C风格字符串  </p><p>如果视字符数组为 “C++风格” 的字符串: string 或 string_view。那么字符串的大小需要被以某种方式指定。  </p><p>考虑如下情景：<br>Q: <code>&quot;str&quot;</code> 所代表的字符串应是 <code>&#123; s, t, r &#125;</code> 还是 <code>&#123; s, t, r, NUL &#125;</code>?<br>A: 显然 <code>&quot;str&quot;</code> 应是 <code>&#123; s, t, r &#125;</code>.<br>Q: <code>const char arr[]&#123; &#39;s&#39;, &#39;t&#39;, &#39;r&#39; &#125;</code> 应该是什么?<br>A: 显然 <code>const char arr[]&#123; &#39;s&#39;, &#39;t&#39;, &#39;r&#39; &#125;</code> 应是 <code>&#123; s, t, r &#125;</code>.<br>Q: <code>const char arr[]&#123; &#39;s&#39;, &#39;t&#39;, &#39;r&#39;, &#39;\0&#39; &#125;</code> 应该是什么?<br>A: 显然 <code>const char arr[]&#123; &#39;s&#39;, &#39;t&#39;, &#39;r&#39;, &#39;\0&#39; &#125;</code> 应是 <code>&#123; s, t, r, NUL &#125;</code>.<br>Q: <code>char str[]&#123; &quot;str&quot; &#125;</code> 应该是什么? …  </p><p>(如果你认为<code>&#123; s, t, r &#125;</code>和<code>&#123; s, t, r, NUL &#125;</code>是一回事，那你根本不了解C++的字符串)  </p><p>当我们将字符串作为参数时，参数类型限制了被调用者，它无法知道调用者给的是字符串字面量还是字符数组，因为字符串字面量持有字符数组类型(<code>const char_t[N]</code>)，字符串字面量在被调用者看来并不特别…  </p><div class="big_thing"><b>此处出现一个核心矛盾：字符串字面量与字符数组对象的暧昧关系。它们都持有数组类型，但是字符串字面量具有更强的约束和准确的语义，它作为字符数组同时告诉你最后一个元素不是字符串的一部分，字符数组如果是字符串，无法判断最后一个元素是否是字符串的一部分</b></div>  <br /><p>(如果你认为<code>&#123; s, t, r &#125;</code>和<code>&#123; s, t, r, NUL &#125;</code>是一回事，那你应该去了解std::string和std::string_view，我们不玩字符串以NUL结尾那一套)<br><code>cout &lt;&lt; string_view&#123; &quot;str\0ing&quot;, sizeof(&quot;str\0ing&quot;) - 1 &#125;</code> 将输出<code>string</code>(NUL字符也被输出了，但是它不可见（我使用QtCreator时发现，它的控制台总是会把输出的NUL以一个空格的形式显示出来，它会输出<code>str ing</code>）)。  </p><p>所以我们在c++里真的做不到让<text class="green_text">被调用者</text>区分<code>&quot;str&quot;</code>和<code>const char arr_str[4]&#123; &#39;s&#39;, &#39;t&#39;, &#39;r&#39;, &#39;\0&#39; &#125;</code>吗？  </p><p>做不到！</p><p>所以“字符串的大小需要被指定”，即调用者决定字符串长度。  </p><p>怎么做？  </p><p>仅通过字符串字面量&#x2F;字符数组、即通过 <code>const char*</code> 或 <code>char*</code> 对象(由数组退化为指针这一特性导致)构造string&#x2F;string_view对象的方法，无一例外都需要 <code>traits_type::length</code> 函数求出字符串长度，对于普通的字符数组，可能产生额外开销且可能有隐患。  </p><p>通过宏</p><pre><code class="C++">#define LTOSV(Literal_) ::std::string_view&#123; Literal_, sizeof(Literal_) - 1 &#125;#define LTOWSV(Literal_) ::std::wstring_view&#123; Literal_, sizeof(Literal_) / sizeof(wchar_t) - 1 &#125;// ... // 其他，如 basic_string_view&lt;char8_t&gt; 等的支持</code></pre><p>则不够优雅、非常繁杂、易错且有令人讨厌的名称污染。  </p><p>(C++ 11) 对于字符串字面量，解决方法是<a href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E9%9D%A2%E9%87%8F">用户自定义字面量</a>。<br>对于普通的字符数组，我建议不拿它当字符串看，它就只是字符数组。  </p><p>可悲。  </p><p>(题外话↓)</p><p>不过至少我们还能通过数组类型知道数组大小，可以保障不出现越界访问的情况。<br>考虑这种安全但有些一言难尽的写法<code>(^_^)</code>：</p><pre><code class="C++">template &lt;template T, std::size_t size&gt;[[nodiscard]] inline constexpr std::size_t get_arr_size(T(&amp;arr)[size]) noexcept&#123;    return size;&#125;template &lt;std::integral CharT, std::size_t size&gt;[[nodiscard]] inline constexpr std::size_t get_cstr_length(CharT(&amp;str)[size]) noexcept&#123;    std::size_t len&#123;&#125;;    for (auto c : str)    &#123;        if (c == CharT(&#39;\0&#39;))            break;        ++len;    &#125;    return len;&#125;</code></pre><pre><code class="C++">char arr[] = &#123; &#39;s&#39;, &#39;t&#39;, &#39;r&#39; &#125;;std::cout    &lt;&lt; get_arr_size(&quot;str&quot;) &lt;&lt; &quot; : &quot; &lt;&lt; get_cstr_length(&quot;str&quot;) &lt;&lt; &quot;\n&quot;    &lt;&lt; get_arr_size(arr)   &lt;&lt; &quot; : &quot; &lt;&lt; get_cstr_length(arr)   &lt;&lt; &quot;\n&quot;;</code></pre><p>(↑此为题外话)  </p><hr><p>“得益于”数组会退化为指向偏移量为0处元素的指针，C语言使用者通常会使用<code>const char*</code>和<code>char*</code>来引用C风格字符串，<br>考虑：  </p><pre><code class="C++">[[nodiscard]] constexpr std::string c_style_string(const char* s)&#123;    return &#123; s, std::strlen(s) &#125;; // 我知道这代码很蠢，这只是为了演示而写&#125;</code></pre><pre><code class="C++">auto v = c_style_string(&quot;str\0ing&quot;); // 得到 &#123; &quot;str&quot;, 3 &#125;auto v = c_style_string(&quot;another string&quot;); // 得到 &#123; &quot;another string&quot;, 14 &#125;char wtf[]&#123; &#39;w&#39;, &#39;t&#39;, &#39;f&#39; &#125;;auto v = c_style_string(wtf); // wtf烫烫烫烫烫烫烫烫?</code></pre><p>现在更糟了，退化为指针之后我们怎么得知字符串参数的内存资源有多大？<br>传入参数的一方可以轻易抹除掉字符串“以NUL结尾”这一保证，<br>以至于产生越界访问。<br>甚至<code>char*</code>只是约定俗成被当成字符串，它甚至可能只是单纯地指向某<code>char</code>类型的变量，我们通过类型这一信息无法判断其语义。  </p><pre><code class="C++">// 将字符串内的小写字母改写为大写字母void ToUpper(char* str) // 愚蠢的 c 风格接口&#123;    for (auto* e = str; *e != &#39;\0&#39;; ++e)        if ((*e) &gt;= &#39;a&#39; &amp;&amp; (*e) &lt;= &#39;z&#39;)            *e -= (&#39;a&#39; - &#39;A&#39;);&#125;void foo()&#123;    char bug[]&#123; &#39;b&#39;, &#39;u&#39;, &#39;g&#39; &#125;;    ToUpper(bug); // 轻易导致程序崩溃&#125;void bar()&#123;    char bug = &#39;B&#39;;    ToUpper(&amp;bug); // 蓝的盆.jpg&#125;</code></pre><div class="big_thing"><b>此处出现一个陷阱：字符数组退化为指针，我们丢失了数组长度，且约定的以NUL结尾的规则可以被轻易违背，有越界访问的风险</b></div><p>C风格API给出的解决方案是增加一个表示size的数据，  </p><pre><code class="C++">std::size_t ToUpper(const char* str,                    std::size_t str_len);</code></pre><p>这样看上去解决了问题，但是有“程序员突然发疯填入参数(shit, 7654321)(shit有类型char[4]，假设值为{ ‘s’, ‘h’, ‘i’, ‘t’ })”导致bug的风险，即这个规则也是可以被轻易违背的，用处不大。</p><p>这样的风格应当被弃用！至少我们有了 <code>string</code>、<code>string_view</code>、<code>span</code> 等设施之后就不该再使用它了。</p><hr><h3 id="C-的字符串"><a href="#C-的字符串" class="headerlink" title="C++的字符串"></a>C++的字符串</h3><p>std::string 则保证字符串最后一个字符的下一位置被置为NUL，并提供了c_str()函数获取C风格字符串(通过const char*类型引用字符串)。但是这不意味着<code>std::string</code>的实例是C风格字符串。</p><p><a href="https://zh.cppreference.com/w/cpp/string/basic_string">如果你不了解 string，现在可以马上去了解它</a>。  </p><p>std::string_view 没有保证该串最后一个字符的下一位置为NUL的职责。</p><p><a href="https://zh.cppreference.com/w/cpp/string/basic_string_view">如果你不了解 string_view，现在可以马上去了解它</a>。  </p><hr><p>我们推崇在c++里使用 <code>std::string</code> <code>std::string_view</code> 或类似的类型来表示字符串。</p><p>C风格字符串和<code>std::string_view</code>与<code>std::string</code>有大不同，如果你不这么认为，<br>请考虑：</p><pre><code class="C++">std::string str&#123; &quot;str\0ing&quot;, 7 &#125;;// auto str = &quot;str\0ing&quot;s; // 更好、更现代的形式: 用户自定义字面量// (需要额外操作如 using namespace std::string_literals;)std::string_view str_v&#123; &quot;str\0ing&quot;, 7 &#125;;// auto str_v = &quot;str\0ing&quot;sv; // 描述同上std::cout    &lt;&lt; str   &lt;&lt; &quot;\n&quot;    &lt;&lt; str_v &lt;&lt; &quot;\n&quot;;std::string c_to_s&#123; &quot;str\0ing&quot; &#125;;std::string_view c_to_sv&#123; &quot;str\0ing&quot; &#125;;std::cout    &lt;&lt; c_to_s  &lt;&lt; &quot;\n&quot;    &lt;&lt; c_to_sv &lt;&lt; &quot;\n&quot;;const char cstr_a[]&#123; &quot;str\0ing&quot; &#125;;const char* cstr = &quot;str\0ing&quot;;std::cout    &lt;&lt; cstr_a &lt;&lt; &quot;\n&quot;    &lt;&lt; cstr    &lt;&lt; &quot;\n&quot;;</code></pre><p>并思考结果是什么？输出了什么(留意对NUL的处理)？针对它们的处理有何差异(留意对NUL的处理)？  </p><p>你不能忽视NUL，对它进行的不同处理会导致程序产生不同的输出。<br>即使你觉得“字符串”中就不应该出现NUL。  </p><p>对于 <code>str</code> 和 <code>str_v</code>，它们通过实参 <code>7</code> 知道了字符串长度，不需要额外计算字符串长度，<code>str</code> 和 <code>str_v</code> 所代表的字符串为 <code>&#123; s, t, r, NUL, i, n, g &#125;</code><br>其他不做赘述。  </p><p>或者你担心使用 <code>std::string</code> 的性能而选择<code>char *s = new char[n]</code>，请进行性能测试再做抉择。在以字符串作为输入参数且无需和C风格API打交道的情况下可以考虑使用 <code>string_view</code> 替代 <code>const char*</code>、<code>const char*, size_t</code>、<code>const string&amp;</code>(别跟我说你不被允许使用c++17及以上标准)，<br>如果你最终要调用C风格API，<code>string_view</code> 因不具有保证字符串结尾的位置为NUL的功能而落选，我因为需要和C风格API打交道考虑专为C风格字符串(主要是为字符串字面量)提供一个更现代的类型CStringRef：</p><pre><code class="C++">template &lt;typename CharT&gt;class BasicCStringRef&#123;public:    [[nodiscard]] constexpr size_type size() const noexcept;    [[nodiscard]] constexpr size_type length() const noexcept;    [[nodiscard]] constexpr const_pointer data() const noexcept;    [[nodiscard]] constexpr const_pointer c_str() const noexcept;    [[nodiscard]] constexpr bool empty() const noexcept;    template &lt;typename Traits = ::std::char_traits&lt;CharT&gt;&gt;    [[nodiscard]] constexpr BasicStringView&lt;CharT, Traits&gt; view() const noexcept;    template &lt;typename Traits = ::std::char_traits&lt;CharT&gt;, typename Alloc = ::std::allocator&lt;CharT&gt;&gt;    [[nodiscard]] constexpr BasicString&lt;CharT, Traits, Alloc&gt; to_string() const;    [[nodiscard]] constexpr const_iterator begin() const noexcept;    [[nodiscard]] constexpr const_iterator end() const noexcept;    // 更多设施如operator const CharT*...&#125;;// 为各个字符类型提供 operator&quot;&quot;_csr (const char_t*, std::size_t)...</code></pre><p>并将其纳入了<a href="https://github.com/SunflavourPetals/Petal-Framework/blob/main/Petal~Application/Petal~String.h">我的库</a>中，但它不怎么好(我的水平有限且不太愿意重复string_view的功能)且对于现代C++并没有什么用处，我认为理想情况情况下，抛弃C风格字符串才是好的选择(但这太激进了)。  </p><hr><p>回到最开始的  </p><pre><code class="C++">std::cout &lt;&lt; &quot;Hello world&quot;;</code></pre><p>如果要发泄的话我会说：  </p><p>“ 都 ！ 是 ！ C ！ 害 ！ 的 ！ ” ，  </p><p>然后结束这场发泄——我真希望字符串字面量从一开始就是 string_view 或 CStringRef 这样的设施。  </p><p>好在用户自定义字面量给出了解决方案，然而代价是需要你使用using指令且需要在引号后多打一两个字母。  </p><p>免责声明：<br>我对C语言本身没什么看法，C语言很出色，但是把继续现代C++当成带类的C并写出很多令人头疼的代码是我不愿意看到的。如果语言的使用者出于某种目的需要将指针、字符数组“当作”字符串来使用，那也没问题，C++不会限制程序员的表达，任何人都有权力写他想要的代码，我也无权把自己的观点和守则强加到别人身上。至于这篇文章，很大程度上是在宣泄情绪，因为C++的字符串字面量和我常用的string、string_view等设施结合的不够好(就算是<code>operator&quot;&quot;</code>也需要程序员多打一两个字母，虽然这么说确实有些矫情)。<br>我制作的“CStringRef”本质上杂糅了C风格的字符串和C++的string_view。它既要求字符串尾的数据被置为NUL，又要求字符串不以NUL结束，这种东西在C++中根本没有必要。<br>而对“使用C语言制作程序出现Bug责怪自己水平低、使用C++制作程序出现Bug责怪C++不像C”的说法，我是讨厌的，就算这只是一句玩笑话。  </p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事项和建议：  </p><ul><li><div class="rev">使用现代C++，</div>  </li><li><div class="rev">尽量使用 string 和 string_view，</div>  </li><li><div class="rev">尽量避免使用单独的字符串字面量或字符数组表示字符串，</div>  </li><li><div class="rev">尽量使用用户自定义字面量通过字符串字面量获得string或string_view对象，</div>  </li><li><div class="rev">当函数接收字符串作为输入参数(不修改)时，考虑使用 string_view 做形参的类型：T foo(string_view in);，</div>  </li><li><div class="rev">当函数接收字符串作为输入输出参数且需要修改它的元素时，考虑使用 span&lt;char_t> 做形参的类型(C++20)，</div>  </li><li><div class="rev">当函数接收字符串作为输入输出参数且需要修改它时(可能增长或缩短)，考虑使用 string& 做形参的类型，</div>  </li><li><div class="rev">函数向调用方输出字符串应当优先采用返回值的方式返回 string 类型字符串，</div>  </li><li><div class="rev">不要让 string_view 的生命周期长于它引用的字符串，如不要返回从局部(自动存储期) string 对象得来的 string_view，对于 span 和我的 CStringRef 同理，它们都不拥有资源的所有权，而像是一种“引用”，</div>  </li><li><div class="rev">字符串字面量具有静态存储期。</div></li></ul><hr><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="用户自定义字面量"><a href="#用户自定义字面量" class="headerlink" title="用户自定义字面量"></a>用户自定义字面量</h3><p>(只讨论本文相关的话题，如果想深入了解，请参考<a href="https://zh.cppreference.com/w/cpp/language/user_literal">C++ Reference</a>)  </p><p>所幸 C++ 11 提供了用户自定义字面量(如果你不知道它，请<a href="https://zh.cppreference.com/w/cpp/language/user_literal">点击此处</a>去了解它)，我们能用用户自定义字面量轻松优雅又高效地得到字符串字面量的长度：  </p><pre><code class="C++">[[nodiscard]] std::size_t operator&quot;&quot;_len(const char*, std::size_t length) noexcept&#123;    return length;&#125;void test()&#123;    std::cout &lt;&lt; &quot;string&quot;_len &lt;&lt; &quot;\n&quot;;&#125;</code></pre><p><code>test</code> 函数将输出：  </p><pre><code>6</code></pre><hr><p>当然只是得到长度什么的远远不够，我们可以直接用用户自定义字面量(<code>operator&quot;&quot;s</code>、<code>operator&quot;&quot;sv</code>)取得 string、string_view 对象，并且已由标准库提供。  </p><p>得益于此特性，通过字符串字面量获得 <code>string_view</code>、<code>string</code> 等类型的对象能解决我们遇到的问题，只需要将合适的字符串字面量换成如下形式：  </p><pre><code class="C++">using namespace std::string_literals; // 前提条件, 了解 operator&quot;&quot;s 和 operator&quot;&quot;sv，它们从C++14起被标准库提供// void xxx_strapi(string_type in_arg); // string_type 是某类型的别名// 某函数 xxx_strapi, 参数需要一字符串作为输入参数(不修改)(函数名字起的太糟还望不要纠结命名). // 形参应持有 string_view 类型而非持有 const char* 类型// 也不推荐继续使用 const string&amp; 的形式，因为可能有额外开销尤其是需要申请内存xxx_strapi(&quot;xxx&quot;sv); // 推荐使用 operator&quot;&quot;sv, // string_view 的“性价比”大于继续使用 const char*// 这体现在代码可读性、可维护性等多个方面// operator&quot;&quot;sv 优于 使用 const char*(字符串字面量/字符数组很多情况下会退化为此类型) 对象构造 string_view 的形式std::string str = &quot;xxx&quot;s; // 等同于 auto str = &quot;xxx&quot;s;</code></pre><h4 id="其他话题"><a href="#其他话题" class="headerlink" title="其他话题"></a>其他话题</h4><p>通过字符串字面量获得string_view对象的情景，使用<code>operator&quot;&quot;sv</code>的形式明显优于以下方式</p><ul><li><code>string_view&#123; &quot;sth&quot;, 3 &#125;</code>  </li><li><code>string_view&#123; &quot;sth&quot;, sizeof(&quot;sth&quot;) - 1 &#125;</code>  </li><li><code>string_view&#123; &quot;sth&quot;, &quot;sth&quot;_length &#125;</code></li></ul><p>以上方式需要书写字符串字面量两次(或需要我们根据字符串字面量手动填入字符串长度)，增加了程序出错的可能性！<br>定义宏的方式可以只用我们书写一次字符串字面量，但假设我们遵循“尽量避免宏”这一规则，因为我们有更好的方法：用户自定义字面量，所以不使用宏。  </p><p>更不用说这些形式  </p><ul><li><code>string_view&#123; &quot;sth&quot;, std::strlen(&quot;sth&quot;) &#125;</code>  </li><li><code>string_view&#123; &quot;sth&quot; &#125;</code></li></ul><p>这两种形式需要使用 <code>std::strlen</code> 和 <code>string_view::traits_type::length</code> 函数，尽管绝大多数情况下不会对性能有什么影响，但个人认为不是足够优秀的方式。  </p><hr><p>参考：<br><a href="https://zh.cppreference.com/w/cpp/language/user_literal">cpp-reference-user_literal</a></p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++20 三路比较运算符的使用</title>
      <link href="/2023/09/22/CPP20%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/09/22/CPP20%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<style>    .other_topic {        color: #528252;    }</style><h1 id="C-20三路比较运算符-“”"><a href="#C-20三路比较运算符-“”" class="headerlink" title="C++20三路比较运算符 “&lt;&#x3D;&gt;”"></a>C++20三路比较运算符 “&lt;&#x3D;&gt;”</h1><p>三路比较运算符是 C++20 标准新加入的运算符，本文将介绍三路比较运算符的基本使用和为用户自定义类型提供它的方法。<br>与三路比较运算符相关内容在标头 <code>&lt;compare&gt;</code> 中。</p><h2 id="三路比较运算符的使用"><a href="#三路比较运算符的使用" class="headerlink" title="三路比较运算符的使用"></a>三路比较运算符的使用</h2><h3 id="三路比较运算符的返回值类型"><a href="#三路比较运算符的返回值类型" class="headerlink" title="三路比较运算符的返回值类型"></a>三路比较运算符的返回值类型</h3><p>C++20新增三路比较运算符，用于确定两个值的大小顺序。内置类型的三路比较运算符返回值不为bool类型的纯右值，而是如下类类型之一的一个纯右值。  </p><div id="ordering_types">C++为我们提供的三种相应的类型：</div>  <ul><li><code>std::strong_ordering</code>  </li><li><code>std::partial_ordering</code>  </li><li><code>std::weak_ordering</code></li></ul><p>它们可以被称为“类枚举类型”(使用方法和”C++枚举类-<a href="https://zh.cppreference.com/w/cpp/language/enum" title="cppref">有作用域枚举</a>“有相似之处，但为类类型，故两者是完全不同的东西)。  </p><h3 id="三种ordering的隐式转换"><a href="#三种ordering的隐式转换" class="headerlink" title="三种ordering的隐式转换"></a>三种ordering的隐式转换</h3><p><span id="ordering_cast"> 三种ordering的隐式转换 </span></p><p>其中<code>std::strong_ordering</code>可以隐式转换为<code>std::weak_ordering</code>；<br><code>std::weak_ordering</code>可以隐式转换为<code>std::partial_ordering</code>。</p><h3 id="strong-ordering-强序"><a href="#strong-ordering-强序" class="headerlink" title="strong_ordering 强序"></a>strong_ordering 强序</h3><p>对于整数类型(包括指针类型)和bool类型，三路比较运算的结果是<code>std::strong_ordering</code>类型的，<br>其值为下列值之一：  </p><ul><li><code>std::strong_ordering::less</code> ：指示先序关系，即左操作数小于右操作数  </li><li><code>std::strong_ordering::greater</code> ：指示后序关系，即左操作数大于右操作数  </li><li><code>std::strong_ordering::equivalent</code> ：<text id="intr_equivalent">指示等价关系，即左操作数等于右操作数</text>  </li><li><code>std::strong_ordering::equal</code> (与<a href="#intr_equivalent">equivalent</a>相同)</li></ul><p>注：如果三路比较运算的两操作数一方为bool类型而另一方不是，那么程序非良构。</p><h3 id="partial-ordering-偏序"><a href="#partial-ordering-偏序" class="headerlink" title="partial_ordering 偏序"></a>partial_ordering 偏序</h3><p>对于浮点类型，结果则是<code>std::partial_ordering</code>类型的，<br>其值为下列值之一：  </p><ul><li><code>std::partial_ordering::less</code> ：指示先序关系，即左操作数小于右操作数  </li><li><code>std::partial_ordering::greater</code> ：指示后序关系，即左操作数大于右操作数  </li><li><code>std::partial_ordering::equivalent</code> ：指示等价关系，即左操作数等于右操作数  </li><li><code>std::partial_ordering::unordered</code> ：指示不可比较值的关系，当操作数中存在<code>NaN</code>时结果为<code>unordered</code></li></ul><p>注：正负零的三路比较运算结果为<code>equivalent</code>  </p><h3 id="weak-ordering-弱序"><a href="#weak-ordering-弱序" class="headerlink" title="weak_ordering 弱序"></a>weak_ordering 弱序</h3><p>对于为用户自定义类型提供的三路比较运算符，如果不考虑使用上述两种类型作为返回值类型，则可以考虑<code>std::weak_ordering</code>，<br>其值为下列值之一：  </p><ul><li><code>std::weak_ordering::less</code> ：指示先序关系，即左操作数小于右操作数  </li><li><code>std::weak_ordering::greater</code> ：指示后序关系，即左操作数大于右操作数  </li><li><code>std::weak_ordering::equivalent</code> ：指示等价关系，即左操作数等于右操作数</li></ul><h3 id="更方便地使用ordering"><a href="#更方便地使用ordering" class="headerlink" title="更方便地使用ordering"></a>更方便地使用ordering</h3><p>对于上述提到的类型，C++标准提供了六种和字面量<code>0</code>进行比较的运算符重载，用以确定两个值的大小顺序。设<code>ordering_v</code>为上述三种ordering类型中任意类型的值，则：</p><ol><li><code>ordering_v &gt; 0</code> or <code>0 &lt; ordering_v</code>时 ：对应<code>less</code>  </li><li><code>ordering_v &gt;= 0</code> or <code>0 &lt;= ordering_v</code>时 ：对应<code>less</code>∨<code>equivalent</code>  </li><li><code>ordering_v &lt; 0</code>or<code>0 &gt; ordering_v</code>时 ：对应<code>greater</code>  </li><li><code>ordering_v &lt;= 0</code>or<code>0 &gt;= ordering_v</code>时 ：对应<code>greater</code>∨<code>equivalent</code>  </li><li><code>ordering_v == 0</code> or <code>0 == ordering_v</code>时 ：对应<code>equivalent</code>  </li><li><code>ordering_v != 0</code> or <code>0 != ordering_v</code>时 ：对应┐<code>equivalent</code>(非<code>equivalent</code>)</li></ol><h4 id="具名比较函数"><a href="#具名比较函数" class="headerlink" title="具名比较函数"></a>具名比较函数</h4><p>这些函数取三路比较的结果，并转换为六个关系运算符的结果之一。</p><ol><li><code>std::is_eq</code>  </li><li><code>std::is_neq</code>  </li><li><code>std::is_lt</code>  </li><li><code>std::is_lteq</code>  </li><li><code>std::is_gt</code>  </li><li><code>std::is_gteq</code></li></ol><p>设形参名为<code>ordering_v</code>，这些函数将分别返回：</p><ol><li><code>ordering_v == 0</code>  </li><li><code>ordering_v != 0</code>  </li><li><code>ordering_v &lt; 0</code>  </li><li><code>ordering_v &lt;= 0</code>  </li><li><code>ordering_v &gt; 0</code>  </li><li><code>ordering_v &gt;= 0</code></li></ol><h3 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h3><pre><code class="C++">#include &lt;iostream&gt;// #include &lt;compare&gt; // 相关内容在标头compare中int main()&#123;    using namespace std;    cout &lt;&lt; boolalpha;    auto case_generator = [](auto foo, auto bar)    &#123;        auto print = [](const auto&amp; result)        &#123;            cout                &lt;&lt; &quot; == &quot; &lt;&lt; (result == 0) &lt;&lt; &#39;\n&#39;                &lt;&lt; &quot; != &quot; &lt;&lt; (result != 0) &lt;&lt; &#39;\n&#39;                &lt;&lt; &quot; &lt;  &quot; &lt;&lt; (result &lt;  0) &lt;&lt; &#39;\n&#39;                &lt;&lt; &quot; &lt;= &quot; &lt;&lt; (result &lt;= 0) &lt;&lt; &#39;\n&#39;                &lt;&lt; &quot; &gt;  &quot; &lt;&lt; (result &gt;  0) &lt;&lt; &#39;\n&#39;                &lt;&lt; &quot; &gt;= &quot; &lt;&lt; (result &gt;= 0) &lt;&lt; &#39;\n&#39;;        &#125;;        cout &lt;&lt; &quot;case equivalent\n&quot;;        foo = 100;        bar = 100;        print(foo &lt;=&gt; bar);        cout &lt;&lt; &quot;case less\n&quot;;        foo = 100;        bar = 999;        print(foo &lt;=&gt; bar);        cout &lt;&lt; &quot;case greater\n&quot;;        foo = 999;        bar = 100;        print(foo &lt;=&gt; bar);    &#125;;    cout &lt;&lt; &quot;Integer: \n&quot;;    case_generator(0, 0);    cout &lt;&lt; &quot;Floating point: \n&quot;;    case_generator(0.0, 0.0);    return 0;&#125;</code></pre><p>结果为</p><pre><code>Integer:case equivalent == true != false &lt;  false &lt;= true &gt;  false &gt;= truecase less == false != true &lt;  true &lt;= true &gt;  false &gt;= falsecase greater == false != true &lt;  false &lt;= false &gt;  true &gt;= trueFloating point:case equivalent == true != false &lt;  false &lt;= true &gt;  false &gt;= truecase less == false != true &lt;  true &lt;= true &gt;  false &gt;= falsecase greater == false != true &lt;  false &lt;= false &gt;  true &gt;= true</code></pre><p>对于不同类型间使用三路比较运算符的详细规则，请参阅<a href="https://zh.cppreference.com/w/cpp/language/operator_comparison">cpp-reference</a></p><hr><h2 id="为用户自定义类型提供三路比较运算符"><a href="#为用户自定义类型提供三路比较运算符" class="headerlink" title="为用户自定义类型提供三路比较运算符"></a>为用户自定义类型提供三路比较运算符</h2><p>为用户自定义类型提供三路比较运算符可以将其定义为成员函数和非成员函数(友元)两种方式。</p><p>三路比较运算符返回值类型应当为<a href="#ordering_types">三种ordering</a>中任意一个，但是如果要改变为其他类型比如<code>int</code>也是可以的，程序员在编写代码的时候应该清楚自己在做什么。</p><pre><code class="C++">// 重载三路比较运算符示例// 成员函数形式：class CX1&#123;    int val&#123;&#125;;    int insignificant_things&#123;&#125;;public:    auto operator &lt;=&gt; (const CX1&amp; o) const    &#123;        return this-&gt;val &lt;=&gt; o.val;    &#125;&#125;;// 友元函数形式(推荐)：class CX2&#123;    int val&#123;&#125;;    int insignificant_things&#123;&#125;;public:    friend auto operator &lt;=&gt; (const CX2&amp; ol, const CX2&amp; or)    &#123;        return ol.val &lt;=&gt; or.val;    &#125;&#125;;</code></pre><div class="other_topic">题外话：  <p>我更推荐将某一类型的 <code>+</code>, <code>-</code>, <code>&gt;</code>, <code>==</code>, <code>&lt;=&gt;</code> 等 rhs 与 lhs 地位平等的运算符以非成员函数的形式在与目标类型<code>T</code>所处的命名空间中(无需担心名称查找的问题)提供。  </p><pre><code class="C++">namespace mytest&#123;    struct my_t    &#123;        int data&#123;&#125;;                // 形式一        [[nodiscard]] friend constexpr auto operator== (const my_t&amp; lhs, const my_t&amp; rhs) noexcept        &#123;            return lhs.data == rhs.data;        &#125;    &#125;;    // 形式二(是否需要设置为友元函数请根据情况判断)    [[nodiscard]] constexpr auto operator&lt;=&gt; (const my_t&amp; lhs, const my_t&amp; rhs) noexcept    &#123;        return lhs.data &lt;=&gt; rhs.data;    &#125;&#125;auto foo()&#123;    mytest::my_t a&#123; 1 &#125;, b&#123; 2 &#125;;    return a &lt;=&gt; b; // 可以根据my_t所处的命名空间作用域找到operator&lt;=&gt;&#125;</code></pre><p>题外话的题外话：<br>对于形参，<code>my_t</code> 的拷贝开销很小，使用引用可能还不如使用拷贝方便高效，但是为了形式上的统一，我此处仍然使用<code>const T&amp;</code>形式。我相信在上述情况下(即给出的代码)，编译器最终的优化不会让这种“形式”影响程序的性能。<br>如果担心性能问题，请做性能测试(需要考虑是否可以启用编译器优化等条件)。  </p></div><hr><p>为我们的类型提供了三路比较运算符后，<br>若此函数被定义为<code>=default</code>，则C++会自动生成 <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code> 运算符。<br>若此函数定义不为<code>=default</code>，则C++会自动生成 <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code> 运算符。<br>这是三路比较运算符重载非常有用的一点，如果不需要自动生成的比较运算符可以显式弃置，如果自动生成的比较运算符不和自己的期望，也可以自定义它。  </p><p>注：提供<code>&lt;=&gt;</code>运算符的非默认实现(不定义为<code>=default</code>)后，c++ 不会为我们自动生成<code>==</code>运算符，至于为什么我不知道，有能力可以去翻阅相关提案。  </p><pre><code class="C++">// 示例class CX&#123;    int foo&#123;&#125;;    int bar&#123;&#125;;public:    auto operator &lt;=&gt; (const CX&amp;) const = default;    // 如果我们单不希望此类有 &quot;&gt;=&quot; 比较运算符，则显示弃置它：    bool operator &gt;= (const CX&amp;) const = delete; // 弃置 &gt;= 运算符    // 如果我们单希望 &quot;&gt;&quot; 运算符的比较方式是成员属性之和相比较，而不是根据三路比较运算自动生成的比较方式，则自定义它：    bool operator &gt; (const CX&amp; o) const noexcept    &#123;        return (this-&gt;foo + this-&gt;bar) &gt; (o.foo + o.bar);    &#125;&#125;;</code></pre><h3 id="默认的三路比较运算符重载"><a href="#默认的三路比较运算符重载" class="headerlink" title="默认的三路比较运算符重载"></a>默认的三路比较运算符重载</h3><p>当我们要为一个自定义类型提供三路比较运算符时，有时可以考虑采用默认的三路比较运算符。<br>默认的三路比较运算符返回值根据<a href="#ordering_cast">三种ordering的隐式转换规则</a>采取相应的类型。<br>即：有<code>std::partial_ordering</code>时为<code>std::partial_ordering</code>，否则有<code>std::weak_ordering</code>时为<code>std::weak_ordering</code>，否则为<code>std::strong_ordering</code>。<br>如果想要使用默认的三路比较运算符，类的成员必须全部满足：<strong>类型为基本类型</strong>或<strong>具有重载的返回值为<a href="#ordering_types">上述三种ordering</a>的三路比较运算符</strong>的类型。  </p><p>示例：</p><pre><code class="C++">// 成员函数形式：class CX1&#123;    int foo&#123;&#125;;    int bar&#123;&#125;; // memberspublic:    auto operator &lt;=&gt; (const CX1&amp;) const = default; // 返回类型为 strong_ordering&#125;;// 友元函数形式：class CX2&#123;    int foo&#123;&#125;;    double bar&#123;&#125;; // memberspublic:    friend auto operator &lt;=&gt; (const CX2&amp;, const CX2&amp;) = default; // 返回类型为 partial_ordering&#125;;class CX3&#123;    CX1 cx1&#123;&#125;;    CX2 cx2&#123;&#125;;public:    auto operator &lt;=&gt; (const CX1&amp;) const = default; // 返回类型为 partial_ordering&#125;;</code></pre><p>默认生成的三路比较运算符返回值取决于此：<br>按类中成员顺序进行三路比较，直到结果出现<code>less</code>、<code>greater</code>、<code>unordered</code>或全部比较完成，并将最后一个得到的结果作为整个三路比较运算的结果。</p><p>示例：</p><pre><code class="C++">#include &lt;iostream&gt;struct Test &#123;  int m1; double m2; bool m3; &#125;;int main()&#123;    using std::cout;    Test t1&#123; 1, 2.0, true &#125;;    Test t2&#123; 1, 3.0, false &#125;;    // 第一个成员属性比较结果为 equivalent, 继续    // 第二个成员属性比较结果为 less, 得到结果    if ((t1 &lt;=&gt; t2) &lt; 0) &#123; cout &lt;&lt; &quot;t1 &lt; t2 \n&quot;; &#125;    return 0;&#125;</code></pre><p>结果为</p><pre><code>t1 &lt; t2</code></pre><hr><p><a href="https://zh.cppreference.com/w/cpp/language/operator_comparison" title="zh cppreference operator_comparison">C++参考 | 比较运算符</a><br><a href="https://zh.cppreference.com/w/cpp/header/compare" title="zh cppreference compare">C++参考 | 标头 compare</a>  </p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
          <category> CPP20 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> CPP20 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 使用extern关键字声明全局常量的作用</title>
      <link href="/2023/09/18/CPP%E4%BD%BF%E7%94%A8extern%E5%85%B3%E9%94%AE%E5%AD%97%E5%A3%B0%E6%98%8E%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2023/09/18/CPP%E4%BD%BF%E7%94%A8extern%E5%85%B3%E9%94%AE%E5%AD%97%E5%A3%B0%E6%98%8E%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="#toolongtowatch">太长不看环节</a></p><h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>通常在编写大型C&#x2F;C++程序时，我们会用到分文件编写程序的方式组织代码，按照不同的功能模块(此模块非c++20模块)，将一份程序分成不同的部分。</p><p>为了让模块之间能够相互访问，需要将声明放在头文件(.h)中，将定义放在源文件(.c&#x2F;.cpp)中。</p><pre><code class="cpp">// header &quot;foo.h&quot;int foo();</code></pre><pre><code class="cpp">// source &quot;foo.cpp&quot;#include &quot;foo.h&quot;int foo()&#123;    return &#123;&#125;;&#125;</code></pre><p>这样，其他模块只要使用了预处理指令<code>#include &quot;foo.h&quot;</code>，就能使用函数<code>foo</code>了(<del>每个用到<code>foo</code>的源文件中，直接在使用之前声明一次也行</del>)。</p><pre><code class="cpp">// main.cpp#include &quot;foo.h&quot;int main()&#123;    return foo();&#125;</code></pre><hr><p>预处理指令<code>#include &quot;foo.h&quot;</code>的作用仅仅只是在预处理阶段使用”foo.h”文件的内容替换掉这条指令而已。</p><p>也就是说，编译器在编译”main.cpp”阶段，代码中只有孤零零一条声明：<code>int foo();</code>，而没有函数<code>foo</code>的定义，大家都不知道这个函数<code>foo</code>在哪里，也不知道这个函数<code>foo</code>干了什么，只知道有个叫<code>foo</code>的函数并且这里调用了函数<code>foo</code>。</p><p>虽然有些疑问，但是”main.cpp”还是被成功编译了，生成了一个”main.obj”(Windows平台)，<code>.obj</code>文件即”可重定位目标文件”，里面装满了编译器生成的目标代码。这时，”foo.cpp”也被编译了，生成了一个”foo.obj”文件……</p><p>现在来到了链接阶段，”main.cpp”中的<code>main</code>函数调用了<code>foo</code>函数，现在我们知道<code>foo</code>函数在”foo.obj”中，链接程序将它和<code>main</code>函数一并放入了”main.exe”(假设是这个名字)，并且在<code>main</code>函数中调用<code>foo</code>函数的地方填上了<code>foo</code>函数的位置。</p><p>这样，<code>main</code>函数就知道<code>foo</code>函数在哪了，当程序执行到此处时，<code>main</code>函数将把控制权交给<code>foo</code>，等着它将返回值交给<code>main</code>……</p><p>这就是小学生都知道的C&#x2F;C++语言从源码到可执行文件的流程。<del>当然，如果你照着上面写了然后还编译链接了，甚至还反编译了，甚至还一条条去看汇编指令了，最后发现<code>main</code>函数直接返回了0，说程序编译链接都是骗人的……别急，这可能是编译器将<code>foo</code>函数直接内联了，用代码替换了函数调用，这不是我们要讨论的内容。</del></p><p>一个内联的例子，用<code>mov eax, 5</code>替换了对函数foo的调用(Release模式下)。</p><img title="例子" src="inline_o.png" data-align="center"><h2 id="Extern-在声明全局变量时的作用"><a href="#Extern-在声明全局变量时的作用" class="headerlink" title="Extern 在声明全局变量时的作用"></a>Extern 在声明全局变量时的作用</h2><p>闹了半天主角”extern”都没出现，现在开始进入正题。</p><p>对函数进行分文件编写是呼吸一样平常的事情，而经常编写C&#x2F;C++程序的话，全局变量&#x2F;命名空间局部变量将是一个绕不开的东西。它也能像函数一样，将声明与定义分离。下面将进行展示~  </p><p>(使用MSVC)</p><pre><code class="cpp">// header &quot;bar.h&quot;extern int bar;</code></pre><pre><code class="cpp">// source &quot;bar.cpp&quot;int bar&#123; 123 &#125;;</code></pre><pre><code class="cpp">// main.cpp#include &quot;bar.h&quot;int main()&#123;    return bar;&#125;</code></pre><p>没错， <code>extern</code>关键字出现了，它告诉链接器这个叫<code>bar</code>的，等会去别的翻译单元中查找定义。通常情况下，非常量全局变量具有外部链接，如你所见，这个<code>bar</code>就是一个非常量全局变量，它具有外部链接，链接器让远在他<code>.obj</code>的<code>main</code>函数也能找到它。</p><hr><div id="toolongtowatch">我所熟知的情况到这就结束了，但是前几天，我在整理旧的代码的时候，发现了一个奇怪又熟悉的东西：</div><pre><code class="cpp">namespace Petal::UserEntrance&#123;    extern const fptr&lt;int&gt; pt_user_main&#123; &amp;::MainFunc &#125;;    extern const ptrc&lt;TChar&gt; pt_user_main_name&#123; Petal_TStr(#MainFunc) &#125;;&#125;</code></pre><p>在定义的时候出现了关键字<code>extern</code>，显然此时我已经忘记了<code>extern</code>在此处的作用，我抱着好奇的心态将它删了(指<code>extern</code>)，结果出现了链接错误：</p><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://learn.microsoft.com/zh-cn/cpp/error-messages/tool-errors/linker-tools-error-lnk2001">LNK2001</a></td><td>无法解析的外部符号 “int (__cdecl* Petal::UserEntrance::pt_user_main)(void)” (?pt_user_main@UserEntrance@Petal@@3Q6AHXZEA)</td></tr><tr><td><a href="https://learn.microsoft.com/zh-cn/cpp/error-messages/tool-errors/linker-tools-error-lnk2001">LNK2001</a></td><td>无法解析的外部符号 “wchar_t const * const Petal::UserEntrance::pt_user_main_name” (?pt_user_main_name@UserEntrance@Petal@@3QEB_WEB)</td></tr><tr><td><a href="https://learn.microsoft.com/zh-cn/cpp/error-messages/tool-errors/linker-tools-error-lnk1120">LNK1120</a></td><td>2 个无法解析的外部命令</td></tr></tbody></table><p>经典链接错误  </p><p><em>Classic</em>  </p><p>我忘记了当时为什么会这样写，查下MSDN。</p><p><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/extern-cpp?view=msvc-170">extern (C++) | Microsoft Learn | zh-cn</a></p><p><a href="https://learn.microsoft.com/en-us/cpp/cpp/extern-cpp?view=msvc-170">extern (C++) | Microsoft Learn | en-us</a></p><p>我果然是健忘的，故写下博客以便未来哪天犯傻了能快速找到之前的经验</p><img title="cat" src="my_cat.jpg" width="298" data-align="center"><p>也就是说，全局常量变量具有内部链接，即使在外声明也无法使用，除非在定义时在前面加上关键字<code>extern</code>。用<code>bar</code>来举例如下：</p><pre><code class="cpp">// header &quot;bar.h&quot;extern const int bar;</code></pre><pre><code class="cpp">// source &quot;bar.cpp&quot;extern const int bar&#123; 123 &#125;;</code></pre><pre><code class="cpp">// main.cpp#include &quot;bar.h&quot;int main()&#123;    return bar;&#125;</code></pre><hr><h2 id="VC-全局变量的链接"><a href="#VC-全局变量的链接" class="headerlink" title="VC++全局变量的链接"></a>VC++全局变量的链接</h2><p>既然都说到这份上，还是复习一下VC++中全局变量(及命名空间局部变量)所具有的链接(不包含C++20及更高标准的内容)。</p><p>仅内部链接：</p><ul><li><p>使用static声明的全局变量或命名空间局部变量</p></li><li><p>类型具有const限定 并且 先前没有外部链接的声明 的全局变量或命名空间局部变量</p></li><li><p>无名命名空间及其中的命名空间中的命名空间局部变量</p></li></ul><p>例</p><pre><code class="cpp">// test.cppstatic int foo&#123; 1 &#125;;const int bar&#123; 2 &#125;;namespace &#123; int unnamed&#123; 3 &#125;; &#125;</code></pre><pre><code class="cpp">// main.cppextern int foo;extern const int bar;extern int baz;int main()&#123;    int&#123; foo &#125;; // LNK2001    int&#123; bar &#125;; // LNK2001    int&#123; baz &#125;; // LNK2001    return 0;&#125;</code></pre><p>外部链接(不在无名命名空间及其中的命名空间内定义的情况)：</p><ul><li><p>使用extern声明的全局变量或命名空间局部变量</p></li><li><p>没有const限定的全局变量或命名空间局部变量</p></li></ul><p>例</p><pre><code class="cpp">// test.cppextern const int foo&#123; 1 &#125;;int bar&#123; 2 &#125;;extern const int baz;const int baz&#123; 3 &#125;;</code></pre><pre><code class="cpp">// main.cppextern const int foo;extern int bar;extern const int baz;int main()&#123;    int&#123; foo &#125;;    int&#123; bar &#125;;    int&#123; baz &#125;;    return 0;&#125;</code></pre><p>值得注意的是，C++引用忽略限定符，所以如下也能通过编译链接(MSVC)：</p><pre><code class="cpp">// test.cppint val&#123; 100 &#125;;int const/*此const限定int*/ &amp;const/*此const无效*/ test&#123; val &#125;;</code></pre><pre><code class="cpp">extern const int&amp; const test;int main()&#123;    int&#123; test &#125;;    return 0;&#125;</code></pre><p>但请不要这么编写代码。</p><p>更复杂的例子(其实分清顶层const和底层const的区别就不会被const限定迷惑住了)</p><pre><code class="cpp">// test.cppint* ptr1&#123; nullptr &#125;; // 外部链接const int* ptrc1&#123; nullptr &#125;; // 外部链接int *const cptr1&#123; nullptr &#125;; // 内部链接int const* const cptrc1&#123; nullptr &#125;; // 内部链接int const* const&amp; cptrcr1&#123; cptrc1 &#125;; // 外部链接extern int const* const cptrc2&#123; nullptr &#125;; // 外部链接</code></pre><p>C++参考</p><p><a href="https://zh.cppreference.com/w/cpp/language/storage_duration">存储类说明符 - cppreference.com</a></p><p><a href="https://en.cppreference.com/w/cpp/language/storage_duration">Storage class specifiers - cppreference.com</a></p><hr><p>完结！</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
          <category> 猝不及防系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 令我猝不及防的CPP_MSVC知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
